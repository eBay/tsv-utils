/**
Command line tool that reads TSV files and summarizes field values associated with 
equivalent keys.

Copyright (c) 2016, eBay Software Foundation
Initially written by Jon Degenhardt

License: Boost Licence 1.0 (http://boost.org/LICENSE_1_0.txt) 
*/
module tsv_summarize;

import std.algorithm : all, any, canFind, each, find, findSplit, map, joiner, splitter;
import std.array : join;
import std.conv;
import std.format;
import std.range;
import std.stdio;
import std.traits;
import std.typecons : tuple;
import std.container : DList;

int main(string[] cmdArgs) {
    TsvSummarizeOptions cmdopt;
    auto r = cmdopt.processArgs(cmdArgs);
    if (!r[0]) {
        return r[1];
    }
    try {
        /* Process the input files.  */
        tsvSummarize(cmdopt, cmdArgs[1..$]);
    }
    catch (Exception exc) {
        stderr.writeln("Error: ", exc.msg);
        return 1;
    }

    return 0;
}

auto helpText = q"EOS
Synopsis: tsv-summarize [options] file [file...]

tsv-summarize reads tab-separated value files, tracking field values for each
unique key and running summarization algorithms. Consider the file data.tsv:

   key value
   a   5
   b   7
   a   3
   c   2
   b   9

The count and sum of unique key is generated by the command:

   $ tsv-summarize --header --key-fields 1 --max 2 --sum 2 data.tsv

This produces:

   key value_max value_sum
   a   5           27
   b   9           28
   c   2           11

The --max and --sum options specify summarization operations. These
operations take a field number and an optional header string. Examples:

  --median 5               # Median of field 5 values
  --median 5:MedianHeight  # Median, with 'MedianHeight' as header

The above follow the standard operator syntax, which is: 

  --<operator-name> FIELD[:header]

Summarization operators are:
  count     min       sum        std     list
  first     max       mean       var     list-asc
  last      range     median     mad     list-dsc

Calculations hold onto the miminum data needed while reading data. However,
operations like median must keep all data values in memory. For such
operations there is a limit on the size of the data that can be processed.

Operations requiring numeric entries will fail and terminate processing if
a non-numeric entry is found.

Options:
EOS";

auto helpTextBrief = q"EOS
Synopsis: tsv-summarize [options] file [file...]

Options:
EOS";

/** Command line options - Container and processing. The processArgs method is used to
 * process the command line.
 */
struct TsvSummarizeOptions {
    /* Options set directly by on the command line.. */
    size_t[] keyFields;              // -k, --key-fields
    size_t[] retainFields;           // -r, --retain-fields
    bool hasHeader = false;          // --header
    bool writeHeader = false;        // -w, --write-header
    char fieldDelimiter = '\t';      // --d|delimiter
    char listDelimiter = ' ';        // --list-delimiter
    bool helpBrief = false;          // --help-brief
    DList!Operator operators;        // Operators, in the order specified.
    size_t endFieldIndex = 0;        // Derived value. Max field index used plus one.

    /* Returns a tuple. First value is true if command line arguments were successfully
     * processed and execution should continue, or false if an error occurred or the user
     * asked for help. If false, the second value is the appropriate exit code (0 or 1).
     *
     * Returning true (execution continues) means args have been validated and derived
     * values calculated. In addition, field indices have been converted to zero-based.
     */ 
    auto processArgs (ref string[] cmdArgs) {
        import std.algorithm : any, each;
        import std.getopt;

        try
        {
            arraySep = ",";    // Use comma to separate values in command line options
            auto r = getopt(
                cmdArgs,
                "help-brief",       "           Print brief help.", &helpBrief,
                "k|key-fields",     "n[,n...]   (Required) Fields to use as join key.", &keyFields,
                "r|retain-fields",  "n[,n...]   Retain one copy of the listed fields.", &retainFields,
                "H|header",         "           Treat the first line of each file as a header.", &hasHeader,
                "w|write-header",   "           Write an output header even if there is no input header.", &writeHeader,
                "d|delimiter",      "CHR        Field delimiter. Default: TAB. (Single byte UTF-8 characters only.)", &fieldDelimiter,
                "list-delimiter",   "CHR        List value delimiter. Default: SPACE. (Single byte UTF-8 characters only.)", &listDelimiter,
                "count",            "           Count occurrences of each unique key", &countOptionHandler,
                "count-header",     "STR        Count occurrences of each unique key, use header STR.", &countHeaderOptionHandler,
                "first",            "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "last",             "FLD[:STR]  Last value of file (numeric fields only).", &operatorOptionHandler!LastOperator,
                "min",              "FLD[:STR]  Min value (numeric fields only).", &operatorOptionHandler!MinOperator,
                "max",              "FLD[:STR]  Max value (numeric fields only).", &operatorOptionHandler!MaxOperator,
                "range",            "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!RangeOperator,
                "sum",              "FLD[:STR]  Sum of the values (numeric fields only).", &operatorOptionHandler!SumOperator,
                "mean",             "FLD[:STR]  Mean (average) of the values (numeric fields only).", &operatorOptionHandler!MeanOperator,
                "median",           "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!MedianOperator,
                "mad",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!MadOperator,
                "list",             "FLD[:STR]  All the values, separated by --list-delimiter.", &operatorOptionHandler!ListOperator,
/*
                "std",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "var",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "list-asc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "list-dsc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
*/
                );

            if (r.helpWanted)
            {
                defaultGetoptPrinter(helpText, r.options);
                return tuple(false, 0);
            }
            else if (helpBrief)
            {
                defaultGetoptPrinter(helpTextBrief, r.options);
                return tuple(false, 0);
            }

            consistencyValidations();
            derivations();
        }
        catch (Exception exc)
        {
            stderr.writeln("Error processing command line arguments: ", exc.msg);
            return tuple(false, 1);
        }
        return tuple(true, 0);
    }
    /* operationOptionHandler functions are callbacks that process command line options
     * specifying summarization operations. eg. '--max 5', '--last 3:LastEntry'. Handlers
     * check syntactic correctness and instantiate Operator objects that do the work. This
     * is also where 1-upped field numbers are converted to 0-based indices.
     */
    private void operatorOptionHandler(OperatorClass : SingleFieldOperator)(string option, string optionVal)
    {
        auto valSplit = findSplit(optionVal, ":");
        
        if (valSplit[0].empty || (!valSplit[1].empty && valSplit[2].empty))
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        
        size_t fieldNum;
        try
        {
            fieldNum = valSplit[0].to!size_t;
        }
        catch (Exception exc)
        {
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        }

        if (fieldNum == 0)
            throw new Exception(
                format("Invalid option: '--%s %s'. Zero is not a valid field index.", option, optionVal));

        size_t fieldIndex = fieldNum - 1;
        
        if (valSplit[2].empty)
            operators.insertBack(new OperatorClass(fieldIndex));
        else
            operators.insertBack(new OperatorClass(fieldIndex, valSplit[2].to!string));
        
        if (fieldIndex >= endFieldIndex)
            endFieldIndex = fieldIndex + 1;
    }

    private void countOptionHandler()
    {
        operators.insertBack(new CountOperator());
    }

    private void countHeaderOptionHandler(string option, string optionVal)
    {
        operators.insertBack(new CountOperator(optionVal));
    }

    /* This routine does validations not handled by processArgs. */
    private void consistencyValidations()
    {
        if (keyFields.any!(x => x == 0))
            throw new Exception("Invalid --k|key-fields option. Field numbers cannot be 0.");

        if (retainFields.any!(x => x == 0))
            throw new Exception("Invalid --r|retain-fields option. Field numbers cannot be 0.");
    }

    /* Post-processing derivations. */
    void derivations() {

        /* keyFields and retainFields need to be made zero-based field indices. They also
         * need to be included in the endFieldIndex, which is one past the last field index.
         */
        [keyFields, retainFields]
            .joiner
            .each!(delegate (ref size_t x) {
                    if (x > endFieldIndex) endFieldIndex = x;
                    --x;
                });
            
        /* Want retain fields printed before summary operators, so add them to the front
         * of the operator list.
         */
        retainFields.retro.each!(x => operators.insertFront(new RetainOperator(x)));
    }
}

/** tsvSummarize does the primary work of the tsv-summarize program.
 */
void tsvSummarize(TsvSummarizeOptions cmdopt, in string[] inputFiles)
{
    /* Pick the Summarizer based on the number of key-fields entered. */
    auto summarizer =
        (cmdopt.keyFields.length == 0)
        ? new NoKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.fieldDelimiter)
        
        : (cmdopt.keyFields.length == 1)
        ? new OneKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields[0], cmdopt.fieldDelimiter)
        
        : new MultiKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields, cmdopt.fieldDelimiter);

    /* Add the operators to the Summarizer. */
    summarizer.setOperators(inputRangeObject(cmdopt.operators[]));

    /* Process each input file, one line at a time. */
    auto lineFields = new char[][](cmdopt.endFieldIndex);
    bool headerFound = false;
    foreach (filename; (inputFiles.length > 0) ? inputFiles : ["-"])
    {
        auto inputStream = (filename == "-") ? stdin : filename.File();
        foreach (lineNum, line; inputStream.byLine.enumerate(1))
        {
            /* Copy the needed number of fields to the fields array.
             * Note: The number is zero if no operator needs fields. Notably, the count
             * operator. Used by itself, it counts the number input lines (ala 'wc -l').
             */
            if (cmdopt.endFieldIndex > 0)
            {
                size_t fieldIndex = 0;
                foreach (fieldValue; line.splitter(cmdopt.fieldDelimiter))
                {
                    if (fieldIndex == cmdopt.endFieldIndex) break;
                    lineFields[fieldIndex] = fieldValue;
                    fieldIndex++;
                }

                if (fieldIndex == 0)
                {
                    assert(cmdopt.endFieldIndex > 0);
                    assert(line.length == 0);
                    
                    /* Bug work-around. Empty lines are not handled properly by splitter.
                     *   - Bug: https://issues.dlang.org/show_bug.cgi?id=15735
                     *   - Pull Request: https://github.com/D-Programming-Language/phobos/pull/4030
                     * This can arise for: '$ tsv-summarize -k 1 --count'. This counts the
                     * unique values in field 1. If there's only one column, then an empty
                     * line becomes an empty string for field 1. Work-around: Point to the
                     * line. It's an empty string.
                     */
                    lineFields[fieldIndex] = line;
                    fieldIndex++;
                }

                if (fieldIndex < cmdopt.endFieldIndex)
                {
                    throw new Exception(
                        format("Not enough fields in line. File: %s, Line: %s",
                               (filename == "-") ? "Standard Input" : filename, lineNum));
                }
            }
            
            if (cmdopt.hasHeader && lineNum == 1)
            {
                if (!headerFound)
                {
                    summarizer.processHeaderLine(lineFields);
                    headerFound = true;
                }
            }
            else
            {
                /* Process the line. Processing will fail (throw) if a field cannot be
                 * converted to the expected type.
                 */
                try
                {
                    summarizer.processNextLine(lineFields);
                }
                catch (Exception exc)
                {
                    throw new Exception(
                        format("Could not process line or field: %s\n  File: %s Line: %s%s",
                               exc.msg, (filename == "-") ? "Standard Input" : filename, lineNum,
                               (lineNum == 1) ? "\n  Is this a header line? Use --header to skip." : ""));
                }
            }
        }
    }

    debug writeln("[tsvSummarize] After reading all data.");

    /* Whew! We're done. Run the calculations and print. */
    auto stdoutWriter = stdout.lockingTextWriter;
    
    if (cmdopt.hasHeader || cmdopt.writeHeader)
        summarizer.writeSummaryHeader(stdoutWriter);
    summarizer.writeSummaryBody(stdoutWriter);
}

/* A Summarizer maintains the state of the summarization and performs basic processing.
 * Handling of files and input lines is left to the caller.
 * API:
 * - addOperator - Called after initializing the object for each operator to be processed.
 * - processHeaderLine - Called to process the header line of each file. Returns true if
 *   it was the first header line processed (used when reading multiple files).
 * - processNextLine - Called to process non-header lines.
 * - writeSummaryHeader - Called to write the header line.
 * - writeSummaryBody - Called to write the result lines.
 */
interface Summarizer(OutputRange)
{
    void setOperators(InputRange!Operator op);
    bool processHeaderLine(const char[][] lineFields);
    void processNextLine(const char[][] lineFields);
    void writeSummaryHeader(ref OutputRange outputStream);
    void writeSummaryBody(ref OutputRange outputStream);
}

/* SummarizerBase performs work shared by all sumarizers, most everything except for
 * handling of unique keys. The base class handles creation, allocates storage for 
 * Operators and SharedFieldValues, and similar. Derived classes deal primarily with
 * unique keys and the associated Calculators and UniqueKeyValuesLists.
 */
class SummarizerBase(OutputRange) : Summarizer!OutputRange
{
    private char _fieldDelimiter;
    private bool _hasProcessedFirstHeaderLine = false;
    private SharedFieldValues _sharedFieldValues = null;  // Null if no shared field value lists.
    protected DList!Operator _operators;
    protected size_t _numOperators = 0;

    this(const char fieldDelimiter)
    {
        _fieldDelimiter = fieldDelimiter;
    }

    char fieldDelimiter() const @property
    {
        return _fieldDelimiter;
    }

    /* Sets the Operators used by the Summarizer. Called after construction. */
    void setOperators(InputRange!Operator operators)
    {
        debug writefln("[%s]", __FUNCTION__);
        
        foreach (op; operators)
        {
            _operators.insertBack(op);
            _numOperators++;
            auto numericFieldsToSave = op.numericFieldsToSave();
            auto textFieldsToSave = op.textFieldsToSave();

            debug writefln("  [%s] numericFieldsToSave.length: %d, textFieldsToSave.length: %d",
                           op.to!string, numericFieldsToSave.length, textFieldsToSave.length);



            if (numericFieldsToSave.length > 0 || textFieldsToSave.length > 0)
            {
                if (_sharedFieldValues is null)
                {
                    _sharedFieldValues = new SharedFieldValues();
                }
                numericFieldsToSave.each!(x => _sharedFieldValues.addNumericIndex(x));
                textFieldsToSave.each!(x => _sharedFieldValues.addTextIndex(x));
            }
        }
    }

    bool processHeaderLine(const char[][] lineFields)
    {
        if (!_hasProcessedFirstHeaderLine)
        {
            _operators.each!(x => x.processHeaderLine(lineFields));
            _hasProcessedFirstHeaderLine = true;
            return true;
        }
        else
        {
            return false;
        }
    }

    protected final UniqueKeyValuesLists makeUniqueKeyValuesLists()
    {
        return (_sharedFieldValues is null)
            ? null
            : _sharedFieldValues.makeUniqueKeyValuesLists;
    }

    abstract void processNextLine(const char[][] lineFields);
    abstract void writeSummaryHeader(ref OutputRange outputStream);
    abstract void writeSummaryBody(ref OutputRange outputStream);
}

/* The NoKeySummarizer is used when summarizing values across the entire input.
 */
class NoKeySummarizer(OutputRange) : SummarizerBase!OutputRange
{
    private Calculator[] _calculators;
    private UniqueKeyValuesLists _valueLists;

    this(const char fieldDelimiter)
    {
        super(fieldDelimiter);
    }

    /* Only one Calculator per Operation, so create them as Operators are added. */
    override void setOperators(InputRange!Operator operators)
    {
        super.setOperators(operators);
        foreach (op; operators)
        {
            _calculators ~= op.makeCalculator;
        }
        _valueLists = super.makeUniqueKeyValuesLists();
    }

    override void processNextLine(const char[][] lineFields)
    {
        _calculators.each!(x => x.processNextLine(lineFields));
        if (_valueLists !is null)
        {
            _valueLists.processNextLine(lineFields);
        }
    }

    override void writeSummaryHeader(ref OutputRange outputStream)
    {
        put(outputStream, _operators[].map!(op => op.header).join(fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream)
    {
        put(outputStream,
            _calculators[]
            .map!(x => x.calculate(_valueLists))
            .join(fieldDelimiter));
        put(outputStream, '\n');
    }
}
/* KeySummarizerBase does work shared by the single key and multi-key summarizers. The
 * primary difference between those two is the formation of the key. The primary reason
 * for separating those into two separate classes is to simplify (speed-up) handling of
 * single field keys, which are the most common use case.
 */
class KeySummarizerBase(OutputRange) : SummarizerBase!OutputRange
{
    protected struct UniqueKeyData
    {
        Calculator[] calculators;
        UniqueKeyValuesLists valuesLists;
    }
    
    private DList!string _uniqueKeys;
    private UniqueKeyData[string] _uniqueKeyData;

    this(const char fieldDelimiter)
    {
        super(fieldDelimiter);
    }

    protected void processNextLineWithKey(T : const char[])(T key, const char[][] lineFields)
    {
        debug writefln("[%s]: %s", __FUNCTION__, lineFields.to!string);
        
        auto dataPtr = (key in _uniqueKeyData);
        auto data = (dataPtr is null) ? addUniqueKey(key.to!string) : *dataPtr;
        
        data.calculators.each!(x => x.processNextLine(lineFields));
        if (data.valuesLists !is null)
        {
            data.valuesLists.processNextLine(lineFields);
        }
    }
    
    protected UniqueKeyData addUniqueKey(string key)
    {
        assert(key !in _uniqueKeyData);

        _uniqueKeys.insertBack(key);
        
        auto calculators = new Calculator[_numOperators];
        size_t i = 0;
        foreach (op; _operators)
        {
            calculators[i] = op.makeCalculator;
            i++;
        }
        
        return _uniqueKeyData[key] = UniqueKeyData(calculators, super.makeUniqueKeyValuesLists());
    }
    
    override void writeSummaryHeader(ref OutputRange outputStream)
    {
        put(outputStream, keyFieldHeader());
        put(outputStream, fieldDelimiter);
        put(outputStream, _operators[].map!(op => op.header).join(fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream)
    {
        foreach(key; _uniqueKeys)
        {
            auto data = _uniqueKeyData[key];
            put(outputStream, key);
            put(outputStream, fieldDelimiter);
            put(outputStream,
                data.calculators[]
                .map!(x => x.calculate(data.valuesLists))
                .join(fieldDelimiter));
            put(outputStream, '\n');
        }
    }
    
    abstract string keyFieldHeader() const @property;
}

/* This Summarizer is for the case where the unique key is based on exactly one field.
 */
class OneKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t _keyFieldIndex = 0;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(size_t keyFieldIndex, char fieldDelimiter)
    {
        super(fieldDelimiter);
        _keyFieldIndex = keyFieldIndex;
        _keyFieldHeader = "field" ~ (keyFieldIndex + 1).to!string;
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex <= lineFields.length);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = lineFields[_keyFieldIndex].to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex < lineFields.length);
        processNextLineWithKey(lineFields[_keyFieldIndex], lineFields);
    }
}

/* This Summarizer is for the case where the unique key is based on multiple fields.
 */
class MultiKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t[] _keyFieldIndices;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(const size_t[] keyFieldIndices, char fieldDelimiter)
    {
        super(fieldDelimiter);
        _keyFieldIndices = keyFieldIndices.dup;
        _keyFieldHeader = _keyFieldIndices.map!(x => "field" ~ (x + 1).to!string).join(fieldDelimiter);
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = _keyFieldIndices.map!(i => lineFields[i]).join(fieldDelimiter).to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        string key = _keyFieldIndices.map!(i => lineFields[i]).join(fieldDelimiter).to!string;
        processNextLineWithKey(key, lineFields);
    }
}

/* Summary Operators and Calculators
 * 
 * Two types of objects are used in implementation: Operators and Calculators. An Operator
 * represents a summary calculation specified on the command line, e.g. '--mean 5'. A 
 * Calculator is used to manage the summary calculation for each unique key in the input.
 *
 * As an example, consider the command: 
 *
 *    $tsv-summary --key-field 1 --mean 3 --mean 5
 *
 * This command will create two instances of a MeanOperator, one each for fields 3 and 5.
 * They produce the output field headers (e.g. "field3_mean", "field5_mean"). They also
 * create MeanCalculator objects for each unique value in field 1. For 'mean', a
 * calculator needs to track occurrence count and sum. Calculators produce the final
 * value when all processing is finished.
 *
 * Summary field headers
 *
 * There are several options for specifing summary field headers. The defaults combine the
 * operator name and the header of the field summarized. The defaults can be overridden on
 * on the command line. These scenarios are supported via the operator constructor and the
 * processHeaderLine() method.
 */

interface Operator
{
    @property string header();
    void processHeaderLine(const char[][] fields);
    size_t[] numericFieldsToSave();     // Numeric fields this Operator needs saved
    size_t[] textFieldsToSave();        // Text fields this Operator needs saved
    Calculator makeCalculator();
}

interface Calculator
{
    void processNextLine(const char[][] fields);
    string calculate(UniqueKeyValuesLists valuesLists);
}

/* The SharedFieldValues and UniqueKeyValuesLists classes manage lists of values collected
 * while reading data. Operations like median collect all values and operate on them when
 * running the final calculation. Value lists are needed for each unique key. A command
 * using multiple Operators may save multiple fields. And, different Operators may be run
 * against the same field.
 *
 * The last part motivates these classes. Handling large data sets necessitates minimizing
 * in-memory storage, making it desirable to share identical lists between Calculators.
 * Otherwise, each Calculator could implement its own storage, which would be simpler.
 * 
 * The setup works as follows:
 *  - Operators advertise fields they need saved ([text|numeric]FieldsToSave methods).
 *  - The Summary object keeps a SharedFieldValues object, which in turn keeps list of the
 *    fields shared by Operators. This gets created command initialization.
 *  - The SharedFieldValues object is used to create a UniqueKeyValuesLists object every
 *    time a new unique key is found, alongside the Calculator objects.
 *  - A unique key's UniqueKeyValuesLists object is passed each input line, same as
 *    Calculators, saving the values.
 *  - Calculators retrieve the saved values during the calculation phase.
 *
 * One concession to duplicate storage is that text and numeric versions of the same
 * field might be stored. The reason is because it's important to convert text to numbers
 * as they are read so that useful error messages can be generated. And, storing both
 * forms of the same field should be rare.
 *
 * Built-in calculations - UniqueKeyValueLists have a built-in median operation. This is
 * to avoid repeated calculations of the median by different calculations.
 */

class SharedFieldValues
{
    // Arrays with field indices that need to be saved.
    private size_t[] _numericFieldIndices;
    private size_t[] _textFieldIndices;

    final void addNumericIndex (size_t index)
    {
        if (!canFind(_numericFieldIndices, index))
        {
            _numericFieldIndices ~= index;
        }
    }

    final void addTextIndex (size_t index)
    {
        if (!canFind(_textFieldIndices, index))
        {
            _textFieldIndices ~= index;
        }
    }

    final UniqueKeyValuesLists makeUniqueKeyValuesLists()
    {
        return new UniqueKeyValuesLists(_numericFieldIndices, _textFieldIndices);
    }
}

class UniqueKeyValuesLists
{
    /* A FieldValues object holds is a list of values collect for a specfic field. A
     * unique key may hold several. For example, the command:
     *     $ tsv-summarize --k 1 --median 4 -- median 5
     * requires keeping lists for both fields 4 and 5. This in turn will result in a
     * _numericFieldValues being a 2 element array, one with a list of field 4 values,
     * the second of field 5 values. Linear search is used to find a specific field.
     */
    private FieldValues!double[] _numericFieldValues;
    private FieldValues!string[] _textFieldValues;
    private double[] _numericFieldMedians;

    /* The UniqueKeyValuesLists constructor takes arrays of field indicies to be saved. */
    this(const size_t[] numericFieldIndices, const size_t[] textFieldIndices)
    {
        if (numericFieldIndices.length > 0)
        {
            _numericFieldValues = new FieldValues!double[](numericFieldIndices.length);
            foreach (i, fieldIndex; numericFieldIndices)
                _numericFieldValues[i] = new FieldValues!double(fieldIndex);
        }

        if (textFieldIndices.length > 0)
        {
            _textFieldValues = new FieldValues!string[](textFieldIndices.length);
            foreach (i, fieldIndex; textFieldIndices)
                _textFieldValues[i] = new FieldValues!string(fieldIndex);
        }
    }

    void processNextLine(const char[][] fields)
    {
        _numericFieldValues.each!((ref x) => x.processNextLine(fields));
        _textFieldValues.each!((ref x) => x.processNextLine(fields));
    }

    private FieldValues!double findNumericFieldValues(size_t index)
    {
        alias pred = (FieldValues!double a, size_t b) => (a.fieldIndex == b);
        auto r = find!pred(_numericFieldValues, index);
        assert(!r.empty);
        return r.front;
    }
    
    private FieldValues!string findTextFieldValues(size_t index)
    {
        alias pred = (FieldValues!string a, size_t b) => (a.fieldIndex == b);
        auto r = find!pred(_textFieldValues, index);
        assert(!r.empty);
        return r.front;
    }
    
    final double[] numericValues(size_t index)
    {
        return findNumericFieldValues(index).getArray;
    }
    
    final string[] textValues(size_t index)
    {
        return findTextFieldValues(index).getArray;
    }

    final double numericValuesMedian(size_t index)
    {
        return findNumericFieldValues(index).median;
    }
    
    private class FieldValues(ValueType)
    {
        import std.array : appender;
        private size_t _fieldIndex;
        private Appender!(ValueType[]) _values;
        private bool _haveMedian = false;
        private ValueType _medianValue;
        
        this(size_t fieldIndex)
        {
            _fieldIndex = fieldIndex;
        }

        this(size_t fieldIndex, size_t capacity)
        {
            this(fieldIndex);
            _values.reserve(capacity);
        }
        
        final size_t length() const @property
        {
            return _values.data.length;
        }

        final size_t fieldIndex() const @property
        {
            return _fieldIndex;
        }
        
        final void processNextLine(const char[][] fields)
        {
            debug writefln("[%s]: %s", __FUNCTION__, fields.to!string);
            _values.put(fields[_fieldIndex].to!ValueType);
        }
        
        /* Return a input range of the values. */
        final auto values()
        {
            return _values.data;
        }
        
        final ValueType[] getArray()
        {
            return _values.data;
        }

        final ValueType median()
        {
            if (!_haveMedian)
            {
                _medianValue = _values.data.rangeMedian();
                _haveMedian = true;
            }
            
            return _medianValue;
        }
    }
}

/* Finds the median. Partitions the range via topN in the process. */
auto rangeMedian (Range) (Range r)
    if (isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range)
{
    import std.algorithm : max, reduce, topN;
    import std.traits : isFloatingPoint;

    ElementType!Range median;
    
    if (r.length > 0)
    {
        size_t medianIndex = r.length / 2;
        topN(r, medianIndex);  // Partitions the array
        
        median = r[medianIndex];

        static if (isFloatingPoint!(ElementType!Range))
        {
            if (r.length % 2 == 0)
            {
                /* Even number of values. Split the difference. */
                median = (median + r[0..medianIndex].reduce!max) / 2.0;
            }
        }
    }
    return median;
}

/* SingleFieldOperator is a base class for single field operators, the most common
 * Operator. Derived classes implement makeCalculator and the Calculator class it returns.
 */
class SingleFieldOperator : Operator
{
    private string _name;
    private string _header;
    private size_t _fieldIndex;
    private bool _hasCustomHeader;
    private size_t[] _numericFieldsToSave;
    private size_t[] _textFieldsToSave;

    this(string operatorName, size_t fieldIndex, string summaryHeader, bool hasCustomHeader = true)
    {
        _name = operatorName;
        _fieldIndex = fieldIndex;
        _header = summaryHeader;
        _hasCustomHeader = hasCustomHeader;
    }

    this(string operatorName, size_t fieldIndex)
    {
        string defaultHeader = "field" ~ (fieldIndex + 1).to!string ~ "_" ~ operatorName;
        this(operatorName, fieldIndex, defaultHeader, false);
    }

    final string name() const @property
    {
        return _name;
    }

    /* saveFieldValues[Numeric|Text] are called by derived classes to indicate that field
     * that the field values should be saved. These should called during construction.
     */
    final void setSaveFieldValuesNumeric()
    {
        debug writefln("[%s] _fieldIndex: %d", __FUNCTION__, _fieldIndex);
        _numericFieldsToSave ~= _fieldIndex;
    }
    
    final void setSaveFieldValuesText()
    {
        debug writefln("[%s] _fieldIndex: %d", __FUNCTION__, _fieldIndex);
        _textFieldsToSave ~= _fieldIndex;
    }

    final size_t fieldIndex() const @property
    {
        return _fieldIndex;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields)
    {
        if (!_hasCustomHeader) {
            debug writefln("[%s %d] fields: %s", __FUNCTION__, _fieldIndex, fields.to!string);
            _header = fields[_fieldIndex].to!string ~ "_" ~ _name;
        }
    }

    final size_t[] numericFieldsToSave()
    {
        return _numericFieldsToSave;
    }

    final size_t[] textFieldsToSave()
    {
        return _textFieldsToSave;
    }

    abstract Calculator makeCalculator();
}

/* SingleFieldCalculator is a base class for the common case of calculators using a single
 * field. Derived classes implement processNextField() rather than processNextLine().
 */
class SingleFieldCalculator : Calculator
{
    private size_t _fieldIndex;
    
    this(size_t fieldIndex)
    {
        _fieldIndex = fieldIndex;
    }

    size_t fieldIndex() const @property
    {
        return _fieldIndex;
    }

    void processNextLine(const char[][] fields)
    {
        debug writefln("[%s %d] fields: %s", __FUNCTION__, _fieldIndex, fields.to!string);
        processNextField(fields[_fieldIndex]);
    }
    
    abstract void processNextField(const char[] field);
}

/* Specific operators.
 *
 * Notes: 
 * - The 'Calculator' inner classes are 'static'. This means inner class instances do not
 *   keep a reference to the context of the outer class. In exchange, Calculator instances
 *   need to hold all needed state, typically the field index they are summarizing.
 */

/* CountOperator counts the number of occurrences of each unique key. It differs from most
 * operators in that it doesn't summarize a specific field. Instead it is summarizing a 
 * property of the unique key itself. For this reason it doesn't use SingleFieldOperator.
 */
class CountOperator : Operator
{
    private string _name = "count";
    private string _header = "count";

    this() { }

    this(string summaryHeader)
    {
        _header = summaryHeader;
    }

    final string name() const @property
    {
        return _name;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields) { }

    final size_t[] numericFieldsToSave()
    {
        size_t[] emptyArray;
        return emptyArray;
    }

    final size_t[] textFieldsToSave()
    {
        size_t[] emptyArray;
        return emptyArray;
    }
    
    final Calculator makeCalculator()
    {
        return new CountCalculator();
    }

    static class CountCalculator : Calculator
    {
        private size_t _count = 0;

        final void processNextLine(const char[][] fields)
        {
            debug writefln("[processNextLine %s] fields: %s", __FUNCTION__, fields.to!string);
            _count++;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _count.to!string;
        }
    }
}


class RetainOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("retain", fieldIndex);
    }

    override void processHeaderLine(const char[][] fields)
    {
        debug writefln("[processHeaderLine %s %d] fields: %s", _name, _fieldIndex, fields.to!string);
        _header = fields[fieldIndex].to!string;
    }

    final override Calculator makeCalculator()
    {
        return new RetainCalculator(fieldIndex);
    }

    /* RetainOperator is similar to FirstOperator, except that it preserves the original
     * field name. The intent is for fields that are expected to have same value for each
     * unique key, therefore there is no meaningful summarization to do. But, having the
     * values in the output is still desirable.
     */
    static class RetainCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _value;
        }
    }
}


class FirstOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("first", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("first", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new FirstCalculator(fieldIndex);
    }
    
    static class FirstCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }

        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _value;
        }
    }
}

class LastOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("last", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("last", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new LastCalculator(fieldIndex);
    }

    static class LastCalculator : SingleFieldCalculator
    {
        private string _value = "";
        
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            _value = nextField.to!string;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _value;
        }
    }
}

class MinOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("min", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("min", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MinCalculator(fieldIndex);
    }

    static class MinCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue < _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _value.to!string;
        }
    }
}
        
class MaxOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("max", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("max", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MaxCalculator(fieldIndex);
    }

    static class MaxCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue > _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _value.to!string;
        }
    }
}
        
class RangeOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("range", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("range", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new RangeCalculator(fieldIndex);
    }

    static class RangeCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _minValue = 0.0;
        private double _maxValue = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _minValue = _maxValue = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue > _maxValue)
            {
                _maxValue = fieldValue;
            }
            else if (fieldValue < _minValue)
            {
                _minValue = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return (_maxValue - _minValue).to!string;
        }
    }
}

class SumOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("sum", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("sum", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new SumCalculator(fieldIndex);
    }

    static class SumCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
        }

        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return _total.to!string;
        }
    }
}

class MeanOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mean", fieldIndex);
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mean", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MeanCalculator(fieldIndex);
    }

    static class MeanCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;
        private size_t _count = 0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
            _count++;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return (_total / cast(double) _count).to!string;
        }
    }
}

class MedianOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("median", fieldIndex);
        setSaveFieldValuesNumeric();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("median", fieldIndex, summaryHeader);
        setSaveFieldValuesNumeric();
    }

    final override Calculator makeCalculator()
    {
        return new MedianCalculator(fieldIndex);
    }

    static class MedianCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return valuesLists.numericValuesMedian(fieldIndex).to!string;
        }
    }
}

class MadOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mad", fieldIndex);
        setSaveFieldValuesNumeric();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mad", fieldIndex, summaryHeader);
        setSaveFieldValuesNumeric();
    }

    final override Calculator makeCalculator()
    {
        return new MadCalculator(fieldIndex);
    }

    static class MadCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            import std.math : abs;
            auto median = valuesLists.numericValuesMedian(fieldIndex);
            auto values = valuesLists.numericValues(fieldIndex);
            auto medianDevs = new double[values.length];
            foreach (int i, double v; values)
            {
                medianDevs[i] = abs(v - median);
            }
            return medianDevs.rangeMedian.to!string;
        }
    }
}

class ListOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("list", fieldIndex);
        setSaveFieldValuesText();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("list", fieldIndex, summaryHeader);
        setSaveFieldValuesText();
    }

    final override Calculator makeCalculator()
    {
        return new ListCalculator(fieldIndex);
    }

    static class ListCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists)
        {
            return valuesLists.textValues(fieldIndex).join('|');
        }
    }
}
