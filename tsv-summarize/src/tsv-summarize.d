/**
Command line tool that reads TSV files and summarizes field values associated with 
equivalent keys.

Copyright (c) 2016, eBay Software Foundation
Initially written by Jon Degenhardt

License: Boost Licence 1.0 (http://boost.org/LICENSE_1_0.txt) 
*/
module tsv_summarize;

import std.algorithm : all, any, canFind, each, find, findSplit, map, joiner, splitter;
import std.array : join;
import std.conv;
import std.format;
import std.range;
import std.stdio;
import std.traits;
import std.typecons : tuple;
import std.container : DList;

version(unittest)
{
    // When running unit tests, use main from -main compiler switch.
}
else
{
    int main(string[] cmdArgs) {
        TsvSummarizeOptions cmdopt;
        auto r = cmdopt.processArgs(cmdArgs);
        if (!r[0]) return r[1];
        try tsvSummarize(cmdopt, cmdArgs[1..$]);
        catch (Exception exc)
        {
            stderr.writeln("Error: ", exc.msg);
            return 1;
        }
        return 0;
    }
}

auto helpText = q"EOS
Synopsis: tsv-summarize [options] file [file...]

tsv-summarize reads tab-separated value files, tracking field values for each
unique key and running summarization algorithms. Consider the file data.tsv:

   key value
   a   5
   b   7
   a   3
   c   2
   b   9

The count and sum of unique key is generated by the command:

   $ tsv-summarize --header --group-by 1 --max 2 --sum 2 data.tsv

This produces:

   key value_max value_sum
   a   5           27
   b   9           28
   c   2           11

The --max and --sum options specify summarization operations. These
operations take a field number and an optional header string. Examples:

  --median 5               # Median of field 5 values
  --median 5:MedianHeight  # Median, with 'MedianHeight' as header

The above follow the standard operator syntax, which is: 

  --<operator-name> FIELD[:header]

Summarization operators are:
  count     min       sum        mad
  first     max       mean       mode
  last      range     median     values

Calculations hold onto the miminum data needed while reading data. However,
operations like median must keep all data values in memory. For such
operations there is a limit on the size of the data that can be processed.

Operations requiring numeric entries will fail and terminate processing if
a non-numeric entry is found.

Options:
EOS";

auto helpTextBrief = q"EOS
Synopsis: tsv-summarize [options] file [file...]

Options:
EOS";

/** Command line options - Container and processing. The processArgs method is used to
 * process the command line.
 */
struct TsvSummarizeOptions {
    /* Options set directly by on the command line.. */
    size_t[] keyFields;              // -g, --group-by
    size_t[] retainFields;           // -r, --retain
    bool hasHeader = false;          // --header
    bool writeHeader = false;        // -w, --write-header
    char inputFieldDelimiter = '\t'; // --d|delimiter
    char valuesDelimiter = '|';      // --v|values-delimiter
    bool helpBrief = false;          // --help-brief
    DList!Operator operators;        // Operators, in the order specified.
    size_t endFieldIndex = 0;        // Derived value. Max field index used plus one.

    /* Returns a tuple. First value is true if command line arguments were successfully
     * processed and execution should continue, or false if an error occurred or the user
     * asked for help. If false, the second value is the appropriate exit code (0 or 1).
     *
     * Returning true (execution continues) means args have been validated and derived
     * values calculated. In addition, field indices have been converted to zero-based.
     */ 
    auto processArgs (ref string[] cmdArgs) {
        import std.algorithm : any, each;
        import std.getopt;

        try
        {
            arraySep = ",";    // Use comma to separate values in command line options
            auto r = getopt(
                cmdArgs,
                "help-brief",         "           Print brief help.", &helpBrief,
                "g|group-by",         "n[,n...]   Fields to use as key.", &keyFields,
                "r|retain",           "n[,n...]   Retain one copy of the listed fields.", &retainFields,
                std.getopt.config.caseSensitive,  
                "H|header",           "           Treat the first line of each file as a header.", &hasHeader,
                std.getopt.config.caseInsensitive,
                "w|write-header",     "           Write an output header even if there is no input header.", &writeHeader,
                "d|delimiter",        "CHR        Field delimiter. Default: TAB. (Single byte UTF-8 characters only.)", &inputFieldDelimiter,
                "v|values-delimiter", "CHR        Values delimiter. Default: vertical bar (|). (Single byte UTF-8 characters only.)", &valuesDelimiter,
                "count",              "           Count occurrences of each unique key.", &countOptionHandler,
                "count-header",       "STR        Count occurrences of each unique key, use header STR.", &countHeaderOptionHandler,
                "first",              "FLD[:STR]  First value listed.", &operatorOptionHandler!FirstOperator,
                "last",               "FLD[:STR]  Last value of file.", &operatorOptionHandler!LastOperator,
                "min",                "FLD[:STR]  Min value. (Numeric fields only.)", &operatorOptionHandler!MinOperator,
                "max",                "FLD[:STR]  Max value. Numeric fields only.", &operatorOptionHandler!MaxOperator,
                "range",              "FLD[:STR]  Difference between min and max values. (Numeric fields only.)", &operatorOptionHandler!RangeOperator,
                "sum",                "FLD[:STR]  Sum of the values. (Numeric fields only.)", &operatorOptionHandler!SumOperator,
                "mean",               "FLD[:STR]  Mean (average) of the values. (Numeric fields only.)", &operatorOptionHandler!MeanOperator,
                "median",             "FLD[:STR]  Median value. (Numeric fields only. Reads all values into memory.)", &operatorOptionHandler!MedianOperator,
                "mad",                "FLD[:STR]  Median absolute deviation. Raw value, not scaled. (Numeric fields only. Reads all values into memory.)",
                &operatorOptionHandler!MadOperator,
                "mode",               "FLD[:STR]  Mode. The most frequent value (text). Reads all values into memory.", &operatorOptionHandler!ModeOperator,
                "count-unique",       "FLD[:STR]  Number of unique values (text). Reads all values into memory.", &operatorOptionHandler!UniqueCountOperator,
                "values",             "FLD[:STR]  All the values, separated by --v|values-delimiter.", &operatorOptionHandler!ValuesOperator,

                /*  Not implemented yet.
                "std",                "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "var",                "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "values-asc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "values-dsc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
            */
                );

            if (r.helpWanted)
            {
                defaultGetoptPrinter(helpText, r.options);
                return tuple(false, 0);
            }
            else if (helpBrief)
            {
                defaultGetoptPrinter(helpTextBrief, r.options);
                return tuple(false, 0);
            }

            consistencyValidations();
            derivations();
        }
        catch (Exception exc)
        {
            stderr.writeln("Error processing command line arguments: ", exc.msg);
            return tuple(false, 1);
        }
        return tuple(true, 0);
    }
    /* operationOptionHandler functions are callbacks that process command line options
     * specifying summarization operations. eg. '--max 5', '--last 3:LastEntry'. Handlers
     * check syntactic correctness and instantiate Operator objects that do the work. This
     * is also where 1-upped field numbers are converted to 0-based indices.
     */
    private void operatorOptionHandler(OperatorClass : SingleFieldOperator)(string option, string optionVal)
    {
        auto valSplit = findSplit(optionVal, ":");
        
        if (valSplit[0].empty || (!valSplit[1].empty && valSplit[2].empty))
        {
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        }
        
        size_t fieldNum;
        try fieldNum = valSplit[0].to!size_t;
        catch (Exception exc)
        {
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        }

        if (fieldNum == 0)
            throw new Exception(
                format("Invalid option: '--%s %s'. Zero is not a valid field index.", option, optionVal));

        size_t fieldIndex = fieldNum - 1;
        
        if (valSplit[2].empty)
        {
            operators.insertBack(new OperatorClass(fieldIndex));
        }
        else
        {
            operators.insertBack(new OperatorClass(fieldIndex, valSplit[2].to!string));
        }
        
        if (fieldIndex >= endFieldIndex)
        {
            endFieldIndex = fieldIndex + 1;
        }
    }

    private void countOptionHandler()
    {
        operators.insertBack(new CountOperator());
    }

    private void countHeaderOptionHandler(string option, string optionVal)
    {
        operators.insertBack(new CountOperator(optionVal));
    }

    /* This routine does validations not handled by processArgs. */
    private void consistencyValidations()
    {
        if (keyFields.any!(x => x == 0))
        {
            throw new Exception("Invalid --g|group-by option. Field numbers cannot be 0.");
        }

        if (retainFields.any!(x => x == 0))
        {
            throw new Exception("Invalid --r|retain option. Field numbers cannot be 0.");
        }

        if (inputFieldDelimiter == valuesDelimiter)
        {
            throw new Exception("Cannot use the same character for both --d|field-delimiter and --v|values-delimiter.");
        }
    }

    /* Post-processing derivations. */
    void derivations() {

        /* keyFields and retainFields need to be made zero-based field indices. They also
         * need to be included in the endFieldIndex, which is one past the last field index.
         */
        [keyFields, retainFields]
            .joiner
            .each!(delegate (ref size_t x)
                   {
                       if (x > endFieldIndex) endFieldIndex = x;
                       --x;
                   }
                );
            
        /* Want retain fields printed before summary operators, so add them to the front
         * of the operator list.
         */
        retainFields.retro.each!(x => operators.insertFront(new RetainOperator(x)));
    }
}

/** tsvSummarize does the primary work of the tsv-summarize program.
 */
void tsvSummarize(TsvSummarizeOptions cmdopt, in string[] inputFiles)
{
    /* Pick the Summarizer based on the number of key-fields entered. */
    auto summarizer =
        (cmdopt.keyFields.length == 0)
        ? new NoKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.inputFieldDelimiter)
        
        : (cmdopt.keyFields.length == 1)
        ? new OneKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields[0], cmdopt.inputFieldDelimiter)
        
        : new MultiKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields, cmdopt.inputFieldDelimiter);

    /* Add the operators to the Summarizer. */
    summarizer.setOperators(inputRangeObject(cmdopt.operators[]));

    /* Process each input file, one line at a time. */
    auto lineFields = new char[][](cmdopt.endFieldIndex);
    bool headerFound = false;
    foreach (filename; (inputFiles.length > 0) ? inputFiles : ["-"])
    {
        auto inputStream = (filename == "-") ? stdin : filename.File();
        foreach (lineNum, line; inputStream.byLine.enumerate(1))
        {
            /* Copy the needed number of fields to the fields array.
             * Note: The number is zero if no operator needs fields. Notably, the count
             * operator. Used by itself, it counts the number input lines (ala 'wc -l').
             */
            if (cmdopt.endFieldIndex > 0)
            {
                size_t fieldIndex = 0;
                foreach (fieldValue; line.splitter(cmdopt.inputFieldDelimiter))
                {
                    if (fieldIndex == cmdopt.endFieldIndex) break;
                    lineFields[fieldIndex] = fieldValue;
                    fieldIndex++;
                }

                if (fieldIndex == 0)
                {
                    assert(cmdopt.endFieldIndex > 0);
                    assert(line.length == 0);
                    
                    /* Bug work-around. Empty lines are not handled properly by splitter.
                     *   - Bug: https://issues.dlang.org/show_bug.cgi?id=15735
                     *   - Pull Request: https://github.com/D-Programming-Language/phobos/pull/4030
                     * This can arise for: '$ tsv-summarize -g 1 --count'. This counts the
                     * unique values in field 1. If there's only one column, then an empty
                     * line becomes an empty string for field 1. Work-around: Point to the
                     * line. It's an empty string.
                     */
                    lineFields[fieldIndex] = line;
                    fieldIndex++;
                }

                if (fieldIndex < cmdopt.endFieldIndex)
                {
                    throw new Exception(
                        format("Not enough fields in line. File: %s, Line: %s",
                               (filename == "-") ? "Standard Input" : filename, lineNum));
                }
            }
            
            if (cmdopt.hasHeader && lineNum == 1)
            {
                if (!headerFound)
                {
                    summarizer.processHeaderLine(lineFields);
                    headerFound = true;
                }
            }
            else
            {
                /* Process the line. Processing will fail (throw) if a field cannot be
                 * converted to the expected type.
                 */
                try summarizer.processNextLine(lineFields);
                catch (Exception exc)
                {
                    throw new Exception(
                        format("Could not process line or field: %s\n  File: %s Line: %s%s",
                               exc.msg, (filename == "-") ? "Standard Input" : filename, lineNum,
                               (lineNum == 1) ? "\n  Is this a header line? Use --header to skip." : ""));
                }
            }
        }
    }

    debug writeln("[tsvSummarize] After reading all data.");

    /* Whew! We're done. Run the calculations and print. */
    auto printOptions = SummarizerPrintOptions(cmdopt.inputFieldDelimiter, cmdopt.valuesDelimiter);
    auto stdoutWriter = stdout.lockingTextWriter;
    
    if (cmdopt.hasHeader || cmdopt.writeHeader)
    {
        summarizer.writeSummaryHeader(stdoutWriter, printOptions);
    }

    summarizer.writeSummaryBody(stdoutWriter, printOptions);
}

/* The default field header. This is used when the input doesn't have field headers,
 * but field headers are used in the output. The default is "fieldN", where N is the
 * 1-upped field number.
 */
string headerFromFieldIndex(size_t fieldIndex)
{
    enum prefix = "field";
    return prefix ~ (fieldIndex + 1).to!string;
}

/* Produce a summary header from an existing header. The result has the form
 * "<header>_<operation>". e.g. If the existing header is "length" and the operation is
 * "max", the summary header is "length_max". The existing header typically comes a
 * header line in the input data or was constructed by headerFromFieldIndex().
 */
string summaryHeaderFromHeader(string header, string operationName)
{
    return header ~ "_" ~ operationName;
}

/* SummarizerPrintOptions holds printing options for Summarizers and Calculators. Typically
 * specified with command line options, it is separated out for modularity.
 */
struct SummarizerPrintOptions
{
    char fieldDelimiter;
    char valuesDelimiter;
}

/* A Summarizer maintains the state of the summarization and performs basic processing.
 * Handling of files and input lines is left to the caller.
 * API:
 * - addOperator - Called after initializing the object for each operator to be processed.
 * - processHeaderLine - Called to process the header line of each file. Returns true if
 *   it was the first header line processed (used when reading multiple files).
 * - processNextLine - Called to process non-header lines.
 * - writeSummaryHeader - Called to write the header line.
 * - writeSummaryBody - Called to write the result lines.
 */
interface Summarizer(OutputRange)
{
    void setOperators(InputRange!Operator op);
    bool processHeaderLine(const char[][] lineFields);
    void processNextLine(const char[][] lineFields);
    void writeSummaryHeader(ref OutputRange outputStream, const ref SummarizerPrintOptions);
    void writeSummaryBody(ref OutputRange outputStream, const ref SummarizerPrintOptions);
}

/* SummarizerBase performs work shared by all sumarizers, most everything except for
 * handling of unique keys. The base class handles creation, allocates storage for 
 * Operators and SharedFieldValues, and similar. Derived classes deal primarily with
 * unique keys and the associated Calculators and UniqueKeyValuesLists.
 */
class SummarizerBase(OutputRange) : Summarizer!OutputRange
{
    private char _inputFieldDelimiter;
    private bool _hasProcessedFirstHeaderLine = false;
    private SharedFieldValues _sharedFieldValues = null;  // Null if no shared field value lists.
    protected DList!Operator _operators;
    protected size_t _numOperators = 0;

    this(const char inputFieldDelimiter)
    {
        _inputFieldDelimiter = inputFieldDelimiter;
    }

    char inputFieldDelimiter() const @property
    {
        return _inputFieldDelimiter;
    }

    /* Sets the Operators used by the Summarizer. Called after construction. */
    void setOperators(InputRange!Operator operators)
    {
        debug writefln("[%s]", __FUNCTION__);
        
        foreach (op; operators)
        {
            _operators.insertBack(op);
            _numOperators++;
            auto numericFieldsToSave = op.numericFieldsToSave();
            auto textFieldsToSave = op.textFieldsToSave();

            debug writefln("  [%s] numericFieldsToSave.length: %d, textFieldsToSave.length: %d",
                           op.to!string, numericFieldsToSave.length, textFieldsToSave.length);

            if (numericFieldsToSave.length > 0 || textFieldsToSave.length > 0)
            {
                if (_sharedFieldValues is null)
                {
                    _sharedFieldValues = new SharedFieldValues();
                }
                numericFieldsToSave.each!(x => _sharedFieldValues.addNumericIndex(x));
                textFieldsToSave.each!(x => _sharedFieldValues.addTextIndex(x));
            }
        }
    }

    bool processHeaderLine(const char[][] lineFields)
    {
        if (!_hasProcessedFirstHeaderLine)
        {
            _operators.each!(x => x.processHeaderLine(lineFields));
            _hasProcessedFirstHeaderLine = true;
            return true;
        }
        else
        {
            return false;
        }
    }

    protected final UniqueKeyValuesLists makeUniqueKeyValuesLists()
    {
        return (_sharedFieldValues is null)
            ? null
            : _sharedFieldValues.makeUniqueKeyValuesLists;
    }

    abstract void processNextLine(const char[][] lineFields);
    abstract void writeSummaryHeader(ref OutputRange outputStream, const ref SummarizerPrintOptions);
    abstract void writeSummaryBody(ref OutputRange outputStream, const ref SummarizerPrintOptions);
}

/* The NoKeySummarizer is used when summarizing values across the entire input.
 */
class NoKeySummarizer(OutputRange) : SummarizerBase!OutputRange
{
    private Calculator[] _calculators;
    private UniqueKeyValuesLists _valueLists;

    this(const char inputFieldDelimiter)
    {
        super(inputFieldDelimiter);
    }

    /* Only one Calculator per Operation, so create them as Operators are added. */
    override void setOperators(InputRange!Operator operators)
    {
        super.setOperators(operators);
        foreach (op; operators) _calculators ~= op.makeCalculator;
        _valueLists = super.makeUniqueKeyValuesLists();
    }

    override void processNextLine(const char[][] lineFields)
    {
        _calculators.each!(x => x.processNextLine(lineFields));
        if (_valueLists !is null) _valueLists.processNextLine(lineFields);
    }

    override void writeSummaryHeader(ref OutputRange outputStream, const ref SummarizerPrintOptions printOptions)
    {
        put(outputStream, _operators[].map!(op => op.header).join(printOptions.fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream, const ref SummarizerPrintOptions printOptions)
    {
        put(outputStream,
            _calculators[]
            .map!(x => x.calculate(_valueLists, printOptions))
            .join(printOptions.fieldDelimiter));
        put(outputStream, '\n');
    }
}
/* KeySummarizerBase does work shared by the single key and multi-key summarizers. The
 * primary difference between those two is the formation of the key. The primary reason
 * for separating those into two separate classes is to simplify (speed-up) handling of
 * single field keys, which are the most common use case.
 */
class KeySummarizerBase(OutputRange) : SummarizerBase!OutputRange
{
    protected struct UniqueKeyData
    {
        Calculator[] calculators;
        UniqueKeyValuesLists valuesLists;
    }
    
    private DList!string _uniqueKeys;
    private UniqueKeyData[string] _uniqueKeyData;

    this(const char inputFieldDelimiter)
    {
        super(inputFieldDelimiter);
    }

    protected void processNextLineWithKey(T : const char[])(T key, const char[][] lineFields)
    {
        debug writefln("[%s]: %s", __FUNCTION__, lineFields.to!string);
        
        auto dataPtr = (key in _uniqueKeyData);
        auto data = (dataPtr is null) ? addUniqueKey(key.to!string) : *dataPtr;
        
        data.calculators.each!(x => x.processNextLine(lineFields));
        if (data.valuesLists !is null) data.valuesLists.processNextLine(lineFields);
    }
    
    protected UniqueKeyData addUniqueKey(string key)
    {
        assert(key !in _uniqueKeyData);

        _uniqueKeys.insertBack(key);
        
        auto calculators = new Calculator[_numOperators];
        size_t i = 0;
        foreach (op; _operators)
        {
            calculators[i] = op.makeCalculator;
            i++;
        }
        
        return _uniqueKeyData[key] = UniqueKeyData(calculators, super.makeUniqueKeyValuesLists());
    }
    
    override void writeSummaryHeader(ref OutputRange outputStream, const ref SummarizerPrintOptions printOptions)
    {
        put(outputStream, keyFieldHeader());
        put(outputStream, printOptions.fieldDelimiter);
        put(outputStream, _operators[].map!(op => op.header).join(printOptions.fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream, const ref SummarizerPrintOptions printOptions)
    {
        foreach(key; _uniqueKeys)
        {
            auto data = _uniqueKeyData[key];
            put(outputStream, key);
            put(outputStream, printOptions.fieldDelimiter);
            put(outputStream,
                data.calculators[]
                .map!(x => x.calculate(data.valuesLists, printOptions))
                .join(printOptions.fieldDelimiter));
            put(outputStream, '\n');
        }
    }
    
    abstract string keyFieldHeader() const @property;
}

/* This Summarizer is for the case where the unique key is based on exactly one field.
 */
class OneKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t _keyFieldIndex = 0;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(size_t keyFieldIndex, char inputFieldDelimiter)
    {
        super(inputFieldDelimiter);
        _keyFieldIndex = keyFieldIndex;
        _keyFieldHeader = headerFromFieldIndex(keyFieldIndex);
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex <= lineFields.length);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = lineFields[_keyFieldIndex].to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex < lineFields.length);
        processNextLineWithKey(lineFields[_keyFieldIndex], lineFields);
    }
}

/* This Summarizer is for the case where the unique key is based on multiple fields.
 */
class MultiKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t[] _keyFieldIndices;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(const size_t[] keyFieldIndices, char inputFieldDelimiter)
    {
        super(inputFieldDelimiter);
        _keyFieldIndices = keyFieldIndices.dup;
        _keyFieldHeader =
            _keyFieldIndices.map!(i => headerFromFieldIndex(i))
            .join(inputFieldDelimiter);
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = _keyFieldIndices.map!(i => lineFields[i]).join(inputFieldDelimiter).to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        string key = _keyFieldIndices.map!(i => lineFields[i]).join(inputFieldDelimiter).to!string;
        processNextLineWithKey(key, lineFields);
    }
}

/* Summary Operators and Calculators
 * 
 * Two types of objects are used in implementation: Operators and Calculators. An Operator
 * represents a summary calculation specified on the command line, e.g. '--mean 5'. A 
 * Calculator is used to manage the summary calculation for each unique key in the input.
 *
 * As an example, consider the command: 
 *
 *    $tsv-summary --key-field 1 --mean 3 --mean 5
 *
 * This command will create two instances of a MeanOperator, one each for fields 3 and 5.
 * They produce the output field headers (e.g. "field3_mean", "field5_mean"). They also
 * create MeanCalculator objects for each unique value in field 1. For 'mean', a
 * calculator needs to track occurrence count and sum. Calculators produce the final
 * value when all processing is finished.
 *
 * Summary field headers
 *
 * There are several options for specifing summary field headers. The defaults combine the
 * operator name and the header of the field summarized. The defaults can be overridden on
 * on the command line. These scenarios are supported via the operator constructor and the
 * processHeaderLine() method.
 */

interface Operator
{
    @property string header();
    @property string name();
    void processHeaderLine(const char[][] fields);
    size_t[] numericFieldsToSave();     // Numeric fields this Operator needs saved
    size_t[] textFieldsToSave();        // Text fields this Operator needs saved
    Calculator makeCalculator();
}

interface Calculator
{
    void processNextLine(const char[][] fields);
    string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions);
}

/* The SharedFieldValues and UniqueKeyValuesLists classes manage lists of values collected
 * while reading data. Operations like median collect all values and operate on them when
 * running the final calculation. Value lists are needed for each unique key. A command
 * using multiple Operators may save multiple fields. And, different Operators may be run
 * against the same field.
 *
 * The last part motivates these classes. Handling large data sets necessitates minimizing
 * in-memory storage, making it desirable to share identical lists between Calculators.
 * Otherwise, each Calculator could implement its own storage, which would be simpler.
 * 
 * The setup works as follows:
 *  - Operators advertise fields they need saved ([text|numeric]FieldsToSave methods).
 *  - The Summary object keeps a SharedFieldValues object, which in turn keeps list of the
 *    fields shared by Operators. This gets created command initialization.
 *  - The SharedFieldValues object is used to create a UniqueKeyValuesLists object every
 *    time a new unique key is found, alongside the Calculator objects.
 *  - A unique key's UniqueKeyValuesLists object is passed each input line, same as
 *    Calculators, saving the values.
 *  - Calculators retrieve the saved values during the calculation phase.
 *
 * One concession to duplicate storage is that text and numeric versions of the same
 * field might be stored. The reason is because it's important to convert text to numbers
 * as they are read so that useful error messages can be generated. And, storing both
 * forms of the same field should be rare.
 *
 * Built-in calculations - UniqueKeyValueLists have a built-in median operation. This is
 * to avoid repeated calculations of the median by different calculations.
 */

class SharedFieldValues
{
    // Arrays with field indices that need to be saved.
    private size_t[] _numericFieldIndices;
    private size_t[] _textFieldIndices;

    final void addNumericIndex (size_t index)
    {
        if (!canFind(_numericFieldIndices, index)) _numericFieldIndices ~= index;
    }

    final void addTextIndex (size_t index)
    {
        if (!canFind(_textFieldIndices, index)) _textFieldIndices ~= index;
    }

    final UniqueKeyValuesLists makeUniqueKeyValuesLists()
    {
        return new UniqueKeyValuesLists(_numericFieldIndices, _textFieldIndices);
    }
}

class UniqueKeyValuesLists
{
    /* A FieldValues object holds is a list of values collect for a specfic field. A
     * unique key may hold several. For example, the command:
     *     $ tsv-summarize --k 1 --median 4 -- median 5
     * requires keeping lists for both fields 4 and 5. This in turn will result in a
     * _numericFieldValues being a 2 element array, one with a list of field 4 values,
     * the second of field 5 values. Linear search is used to find a specific field.
     */
    private FieldValues!double[] _numericFieldValues;
    private FieldValues!string[] _textFieldValues;
    private double[] _numericFieldMedians;

    /* The UniqueKeyValuesLists constructor takes arrays of field indicies to be saved. */
    this(const size_t[] numericFieldIndices, const size_t[] textFieldIndices)
    {
        if (numericFieldIndices.length > 0)
        {
            _numericFieldValues = new FieldValues!double[](numericFieldIndices.length);
            foreach (i, fieldIndex; numericFieldIndices)
                _numericFieldValues[i] = new FieldValues!double(fieldIndex);
        }

        if (textFieldIndices.length > 0)
        {
            _textFieldValues = new FieldValues!string[](textFieldIndices.length);
            foreach (i, fieldIndex; textFieldIndices)
                _textFieldValues[i] = new FieldValues!string(fieldIndex);
        }
    }

    void processNextLine(const char[][] fields)
    {
        _numericFieldValues.each!((ref x) => x.processNextLine(fields));
        _textFieldValues.each!((ref x) => x.processNextLine(fields));
    }

    private FieldValues!double findNumericFieldValues(size_t index)
    {
        alias pred = (FieldValues!double a, size_t b) => (a.fieldIndex == b);
        auto r = find!pred(_numericFieldValues, index);
        assert(!r.empty);
        return r.front;
    }
    
    private FieldValues!string findTextFieldValues(size_t index)
    {
        alias pred = (FieldValues!string a, size_t b) => (a.fieldIndex == b);
        auto r = find!pred(_textFieldValues, index);
        assert(!r.empty);
        return r.front;
    }
    
    final double[] numericValues(size_t index)
    {
        return findNumericFieldValues(index).getArray;
    }
    
    final string[] textValues(size_t index)
    {
        return findTextFieldValues(index).getArray;
    }

    final double numericValuesMedian(size_t index)
    {
        return findNumericFieldValues(index).median;
    }
    
    private class FieldValues(ValueType)
    {
        import std.array : appender;
        private size_t _fieldIndex;
        private Appender!(ValueType[]) _values;
        private bool _haveMedian = false;
        private ValueType _medianValue;
        
        this(size_t fieldIndex)
        {
            _fieldIndex = fieldIndex;
        }

        this(size_t fieldIndex, size_t capacity)
        {
            this(fieldIndex);
            _values.reserve(capacity);
        }
        
        final size_t length() const @property
        {
            return _values.data.length;
        }

        final size_t fieldIndex() const @property
        {
            return _fieldIndex;
        }
        
        final void processNextLine(const char[][] fields)
        {
            debug writefln("[%s]: %s", __FUNCTION__, fields.to!string);
            _values.put(fields[_fieldIndex].to!ValueType);
            _haveMedian = false;
        }
        
        /* Return an input range of the values. */
        final auto values()
        {
            return _values.data;
        }
        
        final ValueType[] getArray()
        {
            return _values.data;
        }

        final ValueType median()
        {
            if (!_haveMedian)
            {
                _medianValue = _values.data.rangeMedian();
                _haveMedian = true;
            }
            
            return _medianValue;
        }
    }
}

/* Finds the median. Modifies the range via topN or sort in the process.
 * 
 * Note: topN should be the preferred algorithm, but the current version (Phobos 2.071.1)
 * is pathologically slow for certain data sets. Use sort for now, until an improved
 * topN is available. Set version to rangeMedianViaSort or rangeMedianViaTopN.
 * See: https://issues.dlang.org/show_bug.cgi?id=16517,
 *      http://forum.dlang.org/post/ujuugklmbibuheptdwcn@forum.dlang.org
 */
version(rangeMedianViaTopN) {}
else
{
    version = rangeMedianViaSort;  // The default version, for now.
}

auto rangeMedian (Range) (Range r)
    if (isRandomAccessRange!Range && hasLength!Range && hasSlicing!Range)
{
    version(rangeMedianViaSort)
    {
        version(rangeMedianViaTopN)
        {
            assert(0, "Both rangeMedianViaSort and rangeMedianViaTopN assigned as versions. Assign only one.");
        }
    }
    else version(rangeMedianViaTopN)
    {
    }
    else
    {
        static assert(0, "A version of rangeMedianViaSort or rangeMedianViaTopN must be assigned.");
    }

    import std.traits : isFloatingPoint;
    
    ElementType!Range median;

    if (r.length > 0)
    {
        size_t medianIndex = r.length / 2;
        
        version(rangeMedianViaSort)
        {
            import std.algorithm : sort;
            sort(r);
            median = r[medianIndex];
            
            static if (isFloatingPoint!(ElementType!Range))
            {
                if (r.length % 2 == 0)
                {
                    /* Even number of values. Split the difference. */
                    median = (median + r[medianIndex - 1]) / 2.0;
                }
            }
        }
        else version(rangeMedianViaTopN)
        {
            import std.algorithm : max, reduce, topN;
            topN(r, medianIndex);
            median = r[medianIndex];
            
            static if (isFloatingPoint!(ElementType!Range))
            {
                if (r.length % 2 == 0)
                {
                    /* Even number of values. Split the difference. */
                    if (r[medianIndex - 1] < median)
                    {
                        /* Note: Upcoming phobos has maxElement. */
                        median = (median + r[0..medianIndex].reduce!max) / 2.0;
                    }
                }
            }
        }
        else
        {
            static assert(0, "A version of rangeMedianViaSort or rangeMedianViaTopN must be assigned.");
        }
    }
    
    return median;
}

/* rangeMedian unit tests. */
unittest
{
    import std.math : isNaN;
    import std.algorithm : all, permutations;

    // Median of empty range is (type).init. Zero for int, nan for floats/doubles
    assert(rangeMedian(new int[0]) == int.init);
    assert(rangeMedian(new double[0]).isNaN && double.init.isNaN);
    assert(rangeMedian(new string[0]) == "");
    
    assert(rangeMedian([3]) == 3);
    assert(rangeMedian([3.0]) == 3.0);
    assert(rangeMedian([3.5]) == 3.5);
    assert(rangeMedian(["aaa"]) == "aaa");
    
    /* Even number of elements: Split the difference for floating point, but not other types. */
    assert(rangeMedian([3, 4]) == 4);
    assert(rangeMedian([3.0, 4.0]) == 3.5);
    
    assert(rangeMedian([3, 6, 12]) == 6);
    assert(rangeMedian([3.0, 6.5, 12.5]) == 6.5);
    
    // Do the rest with permutations
    assert([4, 7].permutations.all!(x => (x.rangeMedian == 7)));
    assert([4.0, 7.0].permutations.all!(x => (x.rangeMedian == 5.5)));
    assert(["aaa", "bbb"].permutations.all!(x => (x.rangeMedian == "bbb")));
    
    assert([4, 7, 19].permutations.all!(x => (x.rangeMedian == 7)));
    assert([4.5, 7.5, 19.5].permutations.all!(x => (x.rangeMedian == 7.5)));
    assert(["aaa", "bbb", "ccc"].permutations.all!(x => (x.rangeMedian == "bbb")));

    assert([4.5, 7.5, 19.5, 21.0].permutations.all!(x => (x.rangeMedian == 13.5)));
    assert([4.5, 7.5, 19.5, 20.5, 36.0].permutations.all!(x => (x.rangeMedian == 19.5)));
    assert([4.5, 7.5, 19.5, 24.0, 24.5, 25.0].permutations.all!(x => (x.rangeMedian == 21.75)));
    assert([1.5, 3.25, 3.55, 4.5, 24.5, 25.0, 25.6].permutations.all!(x => (x.rangeMedian == 4.5)));
}

/* SingleFieldOperator is a base class for single field operators, the most common
 * Operator. Derived classes implement makeCalculator and the Calculator class it returns.
 *
 * Unit tests for the SingleFieldOperator base class are included in FirstOperator unit
 * tests.
 */
class SingleFieldOperator : Operator
{
    private string _name;
    private string _header;
    private size_t _fieldIndex;
    private bool _hasCustomHeader;
    private size_t[] _numericFieldsToSave;
    private size_t[] _textFieldsToSave;

    this(string operatorName, size_t fieldIndex, string summaryHeader, bool hasCustomHeader = true)
    {
        _name = operatorName;
        _fieldIndex = fieldIndex;
        _header = summaryHeader;
        _hasCustomHeader = hasCustomHeader;
    }

    this(string operatorName, size_t fieldIndex)
    {
        string defaultHeader = summaryHeaderFromHeader(headerFromFieldIndex(fieldIndex), operatorName);
        this(operatorName, fieldIndex, defaultHeader, false);
    }

    final string name() const @property
    {
        return _name;
    }

    /* saveFieldValues[Numeric|Text] are called by derived classes to indicate that field
     * that the field values should be saved. These should called during construction.
     */
    final void setSaveFieldValuesNumeric()
    {
        debug writefln("[%s] _fieldIndex: %d", __FUNCTION__, _fieldIndex);
        _numericFieldsToSave ~= _fieldIndex;
    }
    
    final void setSaveFieldValuesText()
    {
        debug writefln("[%s] _fieldIndex: %d", __FUNCTION__, _fieldIndex);
        _textFieldsToSave ~= _fieldIndex;
    }

    final size_t fieldIndex() const @property
    {
        return _fieldIndex;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields)
    {
        if (!_hasCustomHeader) {
            debug writefln("[%s %d] fields: %s", __FUNCTION__, _fieldIndex, fields.to!string);
            _header = summaryHeaderFromHeader(fields[_fieldIndex].to!string, _name);
        }
    }

    final size_t[] numericFieldsToSave()
    {
        return _numericFieldsToSave;
    }

    final size_t[] textFieldsToSave()
    {
        return _textFieldsToSave;
    }

    abstract Calculator makeCalculator();
}

/* SingleFieldCalculator is a base class for the common case of calculators using a single
 * field. Derived classes implement processNextField() rather than processNextLine().
 */
class SingleFieldCalculator : Calculator
{
    private size_t _fieldIndex;
    
    this(size_t fieldIndex)
    {
        _fieldIndex = fieldIndex;
    }

    size_t fieldIndex() const @property
    {
        return _fieldIndex;
    }

    void processNextLine(const char[][] fields)
    {
        debug writefln("[%s %d] fields: %s", __FUNCTION__, _fieldIndex, fields.to!string);
        processNextField(fields[_fieldIndex]);
    }
    
    abstract void processNextField(const char[] field);
}

/* Unittest helper functions. Only compiled when -unittest is in effect. */
version(unittest)
{
    /** A helper for SingleFieldOperator unit tests.
     *
     * testSingleFieldOperator takes a set of split file values, a field index, a header
     * suffix, and a set of expected values. The expected values array contains the
     * expected values after each line. An example testing the 'min' operator against a
     * file with 2 columns, 3 rows, using field index 1:
     *
     *    testSingleFieldOperator!MinOperator(
     *       [["10", "100"],           // The split file. 3 lines by 2 rows.
     *        ["5", "50"],
     *        ["20", "200"]],
     *       1,                        // Field index (zero-based)
     *       "min",                    // The header suffix, normally the operator name.
     *       ["100", "50", 50"]);      // Min value after processing each line.
     *
     * Recommended setup is to pick use three "files", one each of a 1x3, 2x3, and 3x3.
     * Then run the operator against each column, a total of six calls. Headers are
     * automatically checked.
     * 
     * These tests do not check unique key behavior (group-by). Operators don't have info
     * about unique keys, and interact with them only indirectly, via Calculators.
     */
    void testSingleFieldOperator(OperatorClass : SingleFieldOperator)
        (const char[][][] splitFile, size_t fieldIndex, string headerSuffix,
         const char[][] expectedValues)
    {
        import std.format : format;
        import std.range : appender;
        import std.string : chomp;
        import std.traits : EnumMembers;

        auto numFields = (splitFile[0]).length;
        
        assert(fieldIndex < numFields,
               format("[testSingleFieldOperator] Invalid field index. headerSuffix: %s",
                      headerSuffix));
        assert(splitFile.length == expectedValues.length,
               format("[testSingleFieldOperator] Number of expected values differs from number of rows. headerSuffix: %s",
                      headerSuffix));

        /* printOptions - Only the 'values-delimiter' (2nd arg) is used these tests. */
        auto printOptions = SummarizerPrintOptions('#', '|');

        /* An input header line. */
        string[] inputHeaderLine = new string[numFields];
        foreach (i; 0 .. numFields) inputHeaderLine[i] = "header" ~ i.to!string;

        /* The different expected output field headers. */
        auto outputFieldHeaderWithNoHeaderLine = summaryHeaderFromHeader(headerFromFieldIndex(fieldIndex), headerSuffix);
        auto outputFieldHeaderFromHeaderLine = summaryHeaderFromHeader(inputHeaderLine[fieldIndex], headerSuffix);
        auto customOutputFieldHeader = "custom";

        enum HeaderUsecase {
            HeaderLine_DefaultHeader,
            HeaderLine_CustomHeader,
            NoHeaderLine_DefaultHeader,
            NoHeaderLine_CustomHeader,
            NoHeaderLine_NoOutputHeader,
        }

        string headerAssertMessage(Operator op, HeaderUsecase hc, const char[] actual, const char[] expected)
        {
            return format("[testSingleFieldOperator] Unexpected header. Operator: %s; Usecase: %s;  Actual: '%s';  Expected: '%s'",
                          op.name, hc, actual, expected);
        }

        string valueAssertMessage(Operator op, HeaderUsecase hc, size_t rowIndex, size_t fieldIndex,
                                  const char[] actual, const char[] expected)
        {
            return format("[testSingleFieldOperator] Unexpected value. Operator: %s; Usecase: %s;  RowIndex: %d, FieldIndex: %d\n    Actual: '%s';  Expected: '%s'",
                          op.name, hc, rowIndex, fieldIndex, actual, expected);
        }

        /* Run the logic for each header use case. Perhaps overkill, but works. */
        foreach (hc; EnumMembers!HeaderUsecase)
        {
            bool hasInputHeader = ( 
                hc == HeaderUsecase.HeaderLine_DefaultHeader ||
                hc == HeaderUsecase.HeaderLine_CustomHeader
                );
            bool hasOutputHeader = (
                hc == HeaderUsecase.HeaderLine_DefaultHeader ||
                hc == HeaderUsecase.HeaderLine_CustomHeader ||
                hc == HeaderUsecase.NoHeaderLine_DefaultHeader ||
                hc == HeaderUsecase.NoHeaderLine_CustomHeader
                );
            bool hasCustomHeader = (
                hc == HeaderUsecase.HeaderLine_CustomHeader ||
                hc == HeaderUsecase.NoHeaderLine_CustomHeader
                );

            if (hasCustomHeader) assert(hasOutputHeader);
            
            Operator[] operatorArray;
            operatorArray ~= hasCustomHeader
                ? new OperatorClass(fieldIndex, customOutputFieldHeader)
                : new OperatorClass(fieldIndex);

            auto summarizer = new NoKeySummarizer!(typeof(appender!(char[])()))('#');
            summarizer.setOperators(inputRangeObject(operatorArray));

            if (hasInputHeader) summarizer.processHeaderLine(inputHeaderLine);

            if (hasOutputHeader)
            {
                /* Write the header line. Note that this is a one-field header, */
                auto headerLineOutput = appender!(char[])();
                summarizer.writeSummaryHeader(headerLineOutput, printOptions);

                /* Test that the header was generated correctly.
                 *
                 * Note: Because the output is generated by a Summarizer, it will have a
                 * trailing newline. Use chomp to trim it.
                 */
                final switch (hc)
                {
                case HeaderUsecase.HeaderLine_DefaultHeader:
                    assert(headerLineOutput.data.chomp == outputFieldHeaderFromHeaderLine,
                           headerAssertMessage(operatorArray[0], hc, headerLineOutput.data.chomp,
                                               outputFieldHeaderFromHeaderLine));
                    break;
                case HeaderUsecase.NoHeaderLine_DefaultHeader:
                    assert(headerLineOutput.data.chomp == outputFieldHeaderWithNoHeaderLine,
                           headerAssertMessage(operatorArray[0], hc, headerLineOutput.data.chomp,
                                               outputFieldHeaderWithNoHeaderLine));
                    break;
                case HeaderUsecase.HeaderLine_CustomHeader:
                case HeaderUsecase.NoHeaderLine_CustomHeader:
                    assert(headerLineOutput.data.chomp == customOutputFieldHeader,
                           headerAssertMessage(operatorArray[0], hc, headerLineOutput.data.chomp,
                                               customOutputFieldHeader));
                    break;
                case HeaderUsecase.NoHeaderLine_NoOutputHeader:
                    break;
               }
                
            }

            /* For each line, process the line, generate the output, and test that the
             * value is correct.
             */
            foreach (i, const char[][] splitLine; splitFile)
            {
                summarizer.processNextLine(splitLine);
                
                auto summaryLineOutput = appender!(char[])();
                summarizer.writeSummaryBody(summaryLineOutput, printOptions);
                assert(summaryLineOutput.data.chomp == expectedValues[i],
                       valueAssertMessage(operatorArray[0], hc, i, fieldIndex,
                                          summaryLineOutput.data.chomp, expectedValues[i]));
            }
        }
    }
}

/* Specific operators.
 *
 * Notes: 
 * - The 'Calculator' inner classes are 'static'. This means inner class instances do not
 *   keep a reference to the context of the outer class. In exchange, Calculator instances
 *   need to hold all needed state, typically the field index they are summarizing.
 */

/** CountOperator counts the number of occurrences of each unique key.
 *
 * CountOperator differs from most other operators in that it doesn't summarize a specific
 * field on the line. Instead it is summarizing a property of the unique key itself. For
 * this reason it doesn't derive from SingleFieldOperator.
 */
class CountOperator : Operator
{
    private string _name = "count";
    private string _header = "count";

    this() { }

    this(string summaryHeader)
    {
        _header = summaryHeader;
    }

    final string name() const @property
    {
        return _name;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields) { }

    final size_t[] numericFieldsToSave()
    {
        size_t[] emptyArray;
        return emptyArray;
    }

    final size_t[] textFieldsToSave()
    {
        size_t[] emptyArray;
        return emptyArray;
    }
    
    final Calculator makeCalculator()
    {
        return new CountCalculator();
    }

    static class CountCalculator : Calculator
    {
        private size_t _count = 0;

        final void processNextLine(const char[][] fields)
        {
            debug writefln("[processNextLine %s] fields: %s", __FUNCTION__, fields.to!string);
            _count++;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _count.to!string;
        }
    }
}

/** RetainOperator retains the first occurrence of a field, without changing the header.
 *
 * RetainOperator is intended for fields where the value is expected to be the same for
 * all occurrences of the unique key, and the goal is to pass the value through unchanged.
 * It is like FirstOperator, except that the original header is preserved.
 *
 * Notes:
 * - An option to signal an error if multiple values are encountered might be useful.
 */
class RetainOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("retain", fieldIndex);
    }

    override void processHeaderLine(const char[][] fields)
    {
        debug writefln("[processHeaderLine %s %d] fields: %s", _name, _fieldIndex, fields.to!string);
        _header = fields[fieldIndex].to!string;
    }

    final override Calculator makeCalculator()
    {
        return new RetainCalculator(fieldIndex);
    }

    static class RetainCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
       {
            return _value;
        }
    }
}

/** FirstOperator outputs the first value found for the field.
 */
class FirstOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("first", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("first", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new FirstCalculator(fieldIndex);
    }
    
    static class FirstCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }

        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _value;
        }
    }
}

unittest
{
    auto a1colFile = [["r1c1"], ["r2c1"], ["r3c1"]];
    auto a2colFile = [["r1c1", "r1c2"], ["r2c1", "r2c2"], ["r3c1", "r3c2"]];
    auto a3colFile = [["r1c1", "r1c2", "r1c3"], ["r2c1", "r2c2", "r2c3"], ["r3c1", "r3c2", "r3c3"]];

    testSingleFieldOperator!FirstOperator(a1colFile, 0, "first", ["r1c1", "r1c1", "r1c1"]);
    testSingleFieldOperator!FirstOperator(a2colFile, 0, "first", ["r1c1", "r1c1", "r1c1"]);
    testSingleFieldOperator!FirstOperator(a2colFile, 1, "first", ["r1c2", "r1c2", "r1c2"]);
    testSingleFieldOperator!FirstOperator(a3colFile, 0, "first", ["r1c1", "r1c1", "r1c1"]);
    testSingleFieldOperator!FirstOperator(a3colFile, 1, "first", ["r1c2", "r1c2", "r1c2"]);
    testSingleFieldOperator!FirstOperator(a3colFile, 2, "first", ["r1c3", "r1c3", "r1c3"]);
}

class LastOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("last", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("last", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new LastCalculator(fieldIndex);
    }

    static class LastCalculator : SingleFieldCalculator
    {
        private string _value = "";
        
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            _value = nextField.to!string;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _value;
        }
    }
}

unittest
{
    auto a1colFile = [["r1c1"], ["r2c1"], ["r3c1"]];
    auto a2colFile = [["r1c1", "r1c2"], ["r2c1", "r2c2"], ["r3c1", "r3c2"]];
    auto a3colFile = [["r1c1", "r1c2", "r1c3"], ["r2c1", "r2c2", "r2c3"], ["r3c1", "r3c2", "r3c3"]];

    testSingleFieldOperator!LastOperator(a1colFile, 0, "last", ["r1c1", "r2c1", "r3c1"]);
    testSingleFieldOperator!LastOperator(a2colFile, 0, "last", ["r1c1", "r2c1", "r3c1"]);
    testSingleFieldOperator!LastOperator(a2colFile, 1, "last", ["r1c2", "r2c2", "r3c2"]);
    testSingleFieldOperator!LastOperator(a3colFile, 0, "last", ["r1c1", "r2c1", "r3c1"]);
    testSingleFieldOperator!LastOperator(a3colFile, 1, "last", ["r1c2", "r2c2", "r3c2"]);
    testSingleFieldOperator!LastOperator(a3colFile, 2, "last", ["r1c3", "r2c3", "r3c3"]);
}

class MinOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("min", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("min", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MinCalculator(fieldIndex);
    }

    static class MinCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue < _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _value.to!string;
        }
    }
}
        
unittest
{
    auto a1colFile = [["10"], ["9.5"], ["11"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["199", "0", "-0.5"], ["3003", "0.2", "12"]];

    testSingleFieldOperator!MinOperator(a1colFile, 0, "min", ["10", "9.5", "9.5"]);
    testSingleFieldOperator!MinOperator(a2colFile, 0, "min", ["20", "20", "20"]);
    testSingleFieldOperator!MinOperator(a2colFile, 1, "min", ["-30", "-30", "-31"]);
    testSingleFieldOperator!MinOperator(a3colFile, 0, "min", ["9009", "199", "199"]);
    testSingleFieldOperator!MinOperator(a3colFile, 1, "min", ["9", "0", "0"]);
    testSingleFieldOperator!MinOperator(a3colFile, 2, "min", ["-4.5", "-4.5", "-4.5"]);
}

class MaxOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("max", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("max", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MaxCalculator(fieldIndex);
    }

    static class MaxCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue > _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _value.to!string;
        }
    }
}
        
unittest
{
    auto a1colFile = [["10"], ["9.5"], ["11"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["199", "0", "-0.5"], ["3003", "0.2", "12"]];

    testSingleFieldOperator!MaxOperator(a1colFile, 0, "max", ["10", "10", "11"]);
    testSingleFieldOperator!MaxOperator(a2colFile, 0, "max", ["20", "21", "22"]);
    testSingleFieldOperator!MaxOperator(a2colFile, 1, "max", ["-30", "-29", "-29"]);
    testSingleFieldOperator!MaxOperator(a3colFile, 0, "max", ["9009", "9009", "9009"]);
    testSingleFieldOperator!MaxOperator(a3colFile, 1, "max", ["9", "9", "9"]);
    testSingleFieldOperator!MaxOperator(a3colFile, 2, "max", ["-4.5", "-0.5", "12"]);
}

class RangeOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("range", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("range", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new RangeCalculator(fieldIndex);
    }

    static class RangeCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _minValue = 0.0;
        private double _maxValue = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _minValue = _maxValue = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue > _maxValue)
            {
                _maxValue = fieldValue;
            }
            else if (fieldValue < _minValue)
            {
                _minValue = fieldValue;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return (_maxValue - _minValue).to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["10"], ["9.5"], ["11"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["199", "0", "-0.5"], ["3003", "0.2", "12"]];

    testSingleFieldOperator!RangeOperator(a1colFile, 0, "range", ["0", "0.5", "1.5"]);
    testSingleFieldOperator!RangeOperator(a2colFile, 0, "range", ["0", "1", "2"]);
    testSingleFieldOperator!RangeOperator(a2colFile, 1, "range", ["0", "1", "2"]);
    testSingleFieldOperator!RangeOperator(a3colFile, 0, "range", ["0", "8810", "8810"]);
    testSingleFieldOperator!RangeOperator(a3colFile, 1, "range", ["0", "9", "9"]);
    testSingleFieldOperator!RangeOperator(a3colFile, 2, "range", ["0", "4", "16.5"]);
}

class SumOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("sum", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("sum", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new SumCalculator(fieldIndex);
    }

    static class SumCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
        }

        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _total.to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["10"], ["9.5"], ["11"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["199", "0", "-0.5"], ["3003", "0.2", "12"]];

    testSingleFieldOperator!SumOperator(a1colFile, 0, "sum", ["10", "19.5", "30.5"]);
    testSingleFieldOperator!SumOperator(a2colFile, 0, "sum", ["20", "41", "63"]);
    testSingleFieldOperator!SumOperator(a2colFile, 1, "sum", ["-30", "-59", "-90"]);
    testSingleFieldOperator!SumOperator(a3colFile, 0, "sum", ["9009", "9208", "12211"]);
    testSingleFieldOperator!SumOperator(a3colFile, 1, "sum", ["9", "9", "9.2"]);
    testSingleFieldOperator!SumOperator(a3colFile, 2, "sum", ["-4.5", "-5", "7"]);
}

class MeanOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mean", fieldIndex);
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mean", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MeanCalculator(fieldIndex);
    }

    static class MeanCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;
        private size_t _count = 0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
            _count++;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return (_total / cast(double) _count).to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["10"], ["9.5"], ["7.5"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["9", "0", "-1.5"], ["4509", "-3", "12"]];

    testSingleFieldOperator!MeanOperator(a1colFile, 0, "mean", ["10", "9.75", "9"]);
    testSingleFieldOperator!MeanOperator(a2colFile, 0, "mean", ["20", "20.5", "21"]);
    testSingleFieldOperator!MeanOperator(a2colFile, 1, "mean", ["-30", "-29.5", "-30"]);
    testSingleFieldOperator!MeanOperator(a3colFile, 0, "mean", ["9009", "4509", "4509"]);
    testSingleFieldOperator!MeanOperator(a3colFile, 1, "mean", ["9", "4.5", "2"]);
    testSingleFieldOperator!MeanOperator(a3colFile, 2, "mean", ["-4.5", "-3", "2"]);
}

class MedianOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("median", fieldIndex);
        setSaveFieldValuesNumeric();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("median", fieldIndex, summaryHeader);
        setSaveFieldValuesNumeric();
    }

    final override Calculator makeCalculator()
    {
        return new MedianCalculator(fieldIndex);
    }

    static class MedianCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return valuesLists.numericValuesMedian(fieldIndex).to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["10"], ["9.5"], ["7.5"]];
    auto a2colFile = [["20", "-30"], ["21", "-29"], ["22", "-31"]];
    auto a3colFile = [["9009", "9", "-4.5"], ["9", "0", "-1.5"], ["4509", "-3", "12"]];

    testSingleFieldOperator!MedianOperator(a1colFile, 0, "median", ["10", "9.75", "9.5"]);
    testSingleFieldOperator!MedianOperator(a2colFile, 0, "median", ["20", "20.5", "21"]);
    testSingleFieldOperator!MedianOperator(a2colFile, 1, "median", ["-30", "-29.5", "-30"]);
    testSingleFieldOperator!MedianOperator(a3colFile, 0, "median", ["9009", "4509", "4509"]);
    testSingleFieldOperator!MedianOperator(a3colFile, 1, "median", ["9", "4.5", "0"]);
    testSingleFieldOperator!MedianOperator(a3colFile, 2, "median", ["-4.5", "-3", "-1.5"]);
}

class MadOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mad", fieldIndex);
        setSaveFieldValuesNumeric();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mad", fieldIndex, summaryHeader);
        setSaveFieldValuesNumeric();
    }

    final override Calculator makeCalculator()
    {
        return new MadCalculator(fieldIndex);
    }

    static class MadCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            import std.math : abs;
            auto median = valuesLists.numericValuesMedian(fieldIndex);
            auto values = valuesLists.numericValues(fieldIndex);
            auto medianDevs = new double[values.length];
            foreach (int i, double v; values)
                medianDevs[i] = abs(v - median);
            return medianDevs.rangeMedian.to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["10"], ["15"], ["20"], ["25"], ["30"]];
    auto a2colFile = [["2", "50"], ["2", "51"], ["2", "52"]];
    auto a3colFile = [["16", "8", "-4"], ["8", "8", "-2"], ["8", "16", "0"]];

    testSingleFieldOperator!MadOperator(a1colFile, 0, "mad", ["0", "2.5", "5", "5", "5"]);
    testSingleFieldOperator!MadOperator(a2colFile, 0, "mad", ["0", "0", "0"]);
    testSingleFieldOperator!MadOperator(a2colFile, 1, "mad", ["0", "0.5", "1"]);
    testSingleFieldOperator!MadOperator(a3colFile, 0, "mad", ["0", "4", "0"]);
    testSingleFieldOperator!MadOperator(a3colFile, 1, "mad", ["0", "0", "0"]);
    testSingleFieldOperator!MadOperator(a3colFile, 2, "mad", ["0", "1", "2"]);
}

class ValuesOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("values", fieldIndex);
        setSaveFieldValuesText();
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("values", fieldIndex, summaryHeader);
        setSaveFieldValuesText();
    }

    final override Calculator makeCalculator()
    {
        return new ValuesCalculator(fieldIndex);
    }

    static class ValuesCalculator : SingleFieldCalculator
    {
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        /* Work is done by saving the field values. */
        final override void processNextField(const char[] nextField)
        { }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return valuesLists.textValues(fieldIndex).join(printOptions.valuesDelimiter);
        }
    }
}

class ModeOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mode", fieldIndex);
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mode", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new ModeCalculator(fieldIndex);
    }

    static class ModeCalculator : SingleFieldCalculator
    {
        private size_t[string] _valueCounts;
        private Appender!(string[]) _uniqueValues;
        
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            auto countPtr = (nextField in _valueCounts);
            
            if (countPtr is null)
            {
                string value = nextField.to!string;
                _uniqueValues.put(value);
                _valueCounts[value] = 1;
            }
            else
            {
                (*countPtr)++;
            }
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            string modeValue = "";
            size_t modeCount = 0;

            foreach (value; _uniqueValues.data)
            {
                assert(value in _valueCounts);

                auto count = _valueCounts[value];
                
                if (count > modeCount)
                {
                    modeValue = value;
                    modeCount = count;
                }
            }
            
            return modeValue;
        }
    }
}

unittest
{
    auto a1colFile = [["a"], ["b"], ["c"], ["c"], ["b"], ["b"], ["a"]];
    auto a2colFile = [["abc", "pqr"], ["def", "pqr"], ["def", "xyz"]];
    auto a3colFile = [["1.0", "1", "a"], ["2.0", "a", "1"], ["2", "a", "1.0"]];

    testSingleFieldOperator!ModeOperator(a1colFile, 0, "mode", ["a", "a", "a", "c", "b", "b", "b"]);
    testSingleFieldOperator!ModeOperator(a2colFile, 0, "mode", ["abc", "abc", "def"]);
    testSingleFieldOperator!ModeOperator(a2colFile, 1, "mode", ["pqr", "pqr", "pqr"]);
    testSingleFieldOperator!ModeOperator(a3colFile, 0, "mode", ["1.0", "1.0", "1.0"]);
    testSingleFieldOperator!ModeOperator(a3colFile, 1, "mode", ["1", "1", "a"]);
    testSingleFieldOperator!ModeOperator(a3colFile, 2, "mode", ["a", "a", "a"]);
}

class UniqueCountOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("unique_count", fieldIndex);
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("unique_count", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new UniqueCountCalculator(fieldIndex);
    }

    static class UniqueCountCalculator : SingleFieldCalculator
    {
        private bool[string] _values;
        
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _values[nextField.to!string] = true;
        }
        
        final string calculate(UniqueKeyValuesLists valuesLists, const ref SummarizerPrintOptions printOptions)
        {
            return _values.length.to!string;
        }
    }
}

unittest
{
    auto a1colFile = [["a"], ["b"], ["c"], ["c"], ["b"], ["b"], ["a"], ["ab"]];
    auto a2colFile = [["abc", "pqr"], ["def", "pqr"], ["def", "xyz"]];
    auto a3colFile = [["1.0", "1", "a"], ["2.0", "a", "1"], ["2", "a", "1.0"]];

    testSingleFieldOperator!UniqueCountOperator(a1colFile, 0, "unique_count", ["1", "2", "3", "3", "3", "3", "3", "4"]);
    testSingleFieldOperator!UniqueCountOperator(a2colFile, 0, "unique_count", ["1", "2", "2"]);
    testSingleFieldOperator!UniqueCountOperator(a2colFile, 1, "unique_count", ["1", "1", "2"]);
    testSingleFieldOperator!UniqueCountOperator(a3colFile, 0, "unique_count", ["1", "2", "3"]);
    testSingleFieldOperator!UniqueCountOperator(a3colFile, 1, "unique_count", ["1", "2", "2"]);
    testSingleFieldOperator!UniqueCountOperator(a3colFile, 2, "unique_count", ["1", "2", "3"]);
}
