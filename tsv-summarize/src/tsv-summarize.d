/**
Command line tool that reads TSV files and summarizes field values associated with 
equivalent keys.

Copyright (c) 2016, eBay Software Foundation
Initially written by Jon Degenhardt

License: Boost Licence 1.0 (http://boost.org/LICENSE_1_0.txt) 
*/
module tsv_summarize;

import std.algorithm : all, any, each, findSplit, map, joiner, splitter;
import std.array : join;
import std.conv;
import std.format;
import std.range;
import std.stdio;
import std.traits;
import std.typecons : tuple;
import std.container : DList;

int main(string[] cmdArgs) {
    TsvSummarizeOptions cmdopt;
    auto r = cmdopt.processArgs(cmdArgs);
    if (!r[0]) {
        return r[1];
    }
    try {
        /* Process the input files.  */
        tsvSummarize(cmdopt, cmdArgs[1..$]);
    }
    catch (Exception exc) {
        stderr.writeln("Error: ", exc.msg);
        return 1;
    }

    return 0;
}

auto helpText = q"EOS
Synopsis: tsv-summarize [options] file [file...]

tsv-summarize reads tab-separated value files, tracking field values for each
unique key and running summarization algorithms. Consider the file data.tsv:

   key value
   a   5
   b   7
   a   3
   c   2
   b   9

The count and sum of unique key is generated by the command:

   $ tsv-summarize --header --key-fields 1 --max 2 --sum 2 data.tsv

This produces:

   key value_max value_sum
   a   5           27
   b   9           28
   c   2           11

The --max and --sum options specify summarization operations. These
operations take a field number and an optional header string. Examples:

  --median 5               # Median of field 5 values
  --median 5:MedianHeight  # Median, with 'MedianHeight' as header

The above follow the standard operator syntax, which is: 

  --<operator-name> FIELD[:header]

Summarization operators are:
  count     min       sum        std     list
  first     max       mean       var     list-asc
  last      range     median     mad     list-dsc

Calculations hold onto the miminum data needed while reading data. However,
operations like median must keep all data values in memory. For such
operations there is a limit on the size of the data that can be processed.

Operations requiring numeric entries will fail and terminate processing if
a non-numeric entry is found.

Options:
EOS";

auto helpTextBrief = q"EOS
Synopsis: tsv-summarize [options] file [file...]

Options:
EOS";

/** Command line options - Container and processing. The processArgs method is used to
 * process the command line.
 */
struct TsvSummarizeOptions {
    /* Options set directly by on the command line.. */
    size_t[] keyFields;              // -k, --key-fields
    size_t[] retainFields;           // -r, --retain-fields
    bool hasHeader = false;          // --header
    bool writeHeader = false;        // -w, --write-header
    char fieldDelimiter = '\t';      // --d|delimiter
    char listDelimiter = ' ';        // --list-delimiter
    bool helpBrief = false;          // --help-brief
    DList!Operator operators;        // Operators, in the order specified.
    size_t endFieldIndex = 0;        // Derived value. Max field index used plus one.

    /* Returns a tuple. First value is true if command line arguments were successfully
     * processed and execution should continue, or false if an error occurred or the user
     * asked for help. If false, the second value is the appropriate exit code (0 or 1).
     *
     * Returning true (execution continues) means args have been validated and derived
     * values calculated. In addition, field indices have been converted to zero-based.
     */ 
    auto processArgs (ref string[] cmdArgs) {
        import std.algorithm : any, each;
        import std.getopt;

        try
        {
            arraySep = ",";    // Use comma to separate values in command line options
            auto r = getopt(
                cmdArgs,
                "help-brief",       "           Print brief help.", &helpBrief,
                "k|key-fields",     "n[,n...]   (Required) Fields to use as join key.", &keyFields,
                "r|retain-fields",  "n[,n...]   Retain one copy of the listed fields.", &retainFields,
                "H|header",         "           Treat the first line of each file as a header.", &hasHeader,
                "w|write-header",   "           Write an output header even if there is no input header.", &writeHeader,
                "d|delimiter",      "CHR        Field delimiter. Default: TAB. (Single byte UTF-8 characters only.)", &fieldDelimiter,
                "list-delimiter",   "CHR        List value delimiter. Default: SPACE. (Single byte UTF-8 characters only.)", &listDelimiter,
                "count",            "           Count occurrences of each unique key", &countOptionHandler,
                "count-header",     "STR        Count occurrences of each unique key, use header STR.", &countHeaderOptionHandler,
                "first",            "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "last",             "FLD[:STR]  Last value of file (numeric fields only).", &operatorOptionHandler!LastOperator,
                "min",              "FLD[:STR]  Min value (numeric fields only).", &operatorOptionHandler!MinOperator,
                "max",              "FLD[:STR]  Max value (numeric fields only).", &operatorOptionHandler!MaxOperator,
                "sum",              "FLD[:STR]  Sum of the values (numeric fields only).", &operatorOptionHandler!SumOperator,
                "mean",             "FLD[:STR]  Mean (average) of the values (numeric fields only).", &operatorOptionHandler!MeanOperator,
/*
                "range",            "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "median",           "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "std",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "var",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "mad",              "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "list",             "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "list-asc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
                "list-dsc",         "FLD[:STR]  First value listed (numeric fields only).", &operatorOptionHandler!FirstOperator,
*/
                );

            if (r.helpWanted)
            {
                defaultGetoptPrinter(helpText, r.options);
                return tuple(false, 0);
            }
            else if (helpBrief)
            {
                defaultGetoptPrinter(helpTextBrief, r.options);
                return tuple(false, 0);
            }

            consistencyValidations();
            derivations();
        }
        catch (Exception exc)
        {
            stderr.writeln("Error processing command line arguments: ", exc.msg);
            return tuple(false, 1);
        }
        return tuple(true, 0);
    }

    private void operatorOptionHandler(OperatorClass : SingleFieldOperator)(string option, string optionVal)
    {
        auto valSplit = findSplit(optionVal, ":");
        
        if (valSplit[0].empty || (!valSplit[1].empty && valSplit[2].empty))
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        
        size_t fieldNum;
        try
        {
            fieldNum = valSplit[0].to!size_t;
        }
        catch (Exception exc)
        {
            throw new Exception(
                format("Invalid option value: '--%s %s'. Expected: '--%s <field>' or '--%s <field>:<val>' where <field> is a number and <val> a string.",
                       option, optionVal, option, option));
        }

        if (fieldNum == 0)
            throw new Exception(
                format("Invalid option: '--%s %s'. Zero is not a valid field index.", option, optionVal));

        size_t fieldIndex = fieldNum - 1;
        
        if (valSplit[2].empty)
            operators.insertBack(new OperatorClass(fieldIndex));
        else
            operators.insertBack(new OperatorClass(fieldIndex, valSplit[2].to!string));
        
        if (fieldIndex >= endFieldIndex)
            endFieldIndex = fieldIndex + 1;
    }

    private void countOptionHandler()
    {
        operators.insertBack(new CountOperator());
    }

    private void countHeaderOptionHandler(string option, string optionVal)
    {
        operators.insertBack(new CountOperator(optionVal));
    }

    /* This routine does validations not handled by processArgs. */
    private void consistencyValidations()
    {
        if (keyFields.any!(x => x == 0))
            throw new Exception("Invalid --k|key-fields option. Field numbers cannot be 0.");

        if (retainFields.any!(x => x == 0))
            throw new Exception("Invalid --r|retain-fields option. Field numbers cannot be 0.");
    }

    /* Post-processing derivations. */
    void derivations() {

        /* keyFields and retainFields need to be made zero-based field indices. They also
         * need to be included in the endFieldIndex, which is one past the last field index.
         */
        [keyFields, retainFields]
            .joiner
            .each!(delegate (ref size_t x) {
                    if (x > endFieldIndex) endFieldIndex = x;
                    --x;
                });
            
        /* Want retain fields printed before summary operators, so add them to the front
         * of the operator list.
         */
        retainFields.retro.each!(x => operators.insertFront(new RetainOperator(x)));
    }
}

/** tsvSummarize does the primary work of the tsv-summarize program.
 */
void tsvSummarize(TsvSummarizeOptions cmdopt, in string[] inputFiles)
{
    /* Summarizer to use depends on number of key-fields entered. */
    auto summarizer =
        (cmdopt.keyFields.length == 0)
        ? new NoKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.fieldDelimiter)
        
        : (cmdopt.keyFields.length == 1)
        ? new OneKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields[0], cmdopt.fieldDelimiter)
        
        : new MultiKeySummarizer!(typeof(stdout.lockingTextWriter()))(cmdopt.keyFields, cmdopt.fieldDelimiter);

    cmdopt.operators.each!(op => summarizer.addOperator(op));

    /* Process each input file, one line at a time. */
    auto lineFields = new char[][](cmdopt.endFieldIndex);
    bool headerFound = false;
    foreach (filename; (inputFiles.length > 0) ? inputFiles : ["-"])
    {
        auto inputStream = (filename == "-") ? stdin : filename.File();
        foreach (lineNum, line; inputStream.byLine.enumerate(1))
        {
            /* Copy the needed number of fields to the fields array. */
            if (cmdopt.endFieldIndex > 0)
            {
                size_t fieldIndex = 0;
                foreach (fieldValue; line.splitter(cmdopt.fieldDelimiter))
                {
                    if (fieldIndex == cmdopt.endFieldIndex) break;
                    lineFields[fieldIndex] = fieldValue;
                    fieldIndex++;
                }

                if (fieldIndex == 0)
                {
                    assert(cmdopt.endFieldIndex > 0);
                    assert(line.length == 0);
                    
                    /* Bug work-around. Empty lines are not handled properly by splitter.
                     *   - Bug: https://issues.dlang.org/show_bug.cgi?id=15735
                     *   - Pull Request: https://github.com/D-Programming-Language/phobos/pull/4030
                     * This can arise for: '$ tsv-summarize -k 1 --count'. This counts the
                     * unique values in field 1. If there's only one column, then an empty
                     * line becomes an empty string for field 1. Work-around: Point to the
                     * line. It's an empty string.
                     */
                    lineFields[fieldIndex] = line;
                    fieldIndex++;
                }

                if (fieldIndex < cmdopt.endFieldIndex)
                {
                    throw new Exception(
                        format("Not enough fields in line. File: %s, Line: %s",
                               (filename == "-") ? "Standard Input" : filename, lineNum));
                }
            }
            
            if (cmdopt.hasHeader && lineNum == 1)
            {
                if (!headerFound)
                {
                    summarizer.processHeaderLine(lineFields);
                    headerFound = true;
                }
            }
            else
            {
                /* Process the line. Processing will fail (throw) if a field cannot be
                 * converted to the expected type.
                 */
                try
                {
                    summarizer.processNextLine(lineFields);
                }
                catch (Exception exc)
                {
                    throw new Exception(
                        format("Could not process line or field: %s\n  File: %s Line: %s%s",
                               exc.msg, (filename == "-") ? "Standard Input" : filename, lineNum,
                               (lineNum == 1) ? "\n  Is this a header line? Use --header to skip." : ""));
                }
            }
        }
    }

    /* Whew! We're done. Run the calculations and print. */
    auto stdoutWriter = stdout.lockingTextWriter;
    
    if (cmdopt.hasHeader || cmdopt.writeHeader)
        summarizer.writeSummaryHeader(stdoutWriter);
    summarizer.writeSummaryBody(stdoutWriter);
}
    
/* Summary Operators and Calculators
 * 
 * Two types of objects are used in implementation: Operators and Calculators. An Operator
 * represents a summary calculation specified on the command line, e.g. '--mean 5'. A 
 * Calculator is used to manage the summary calculation for each unique key in the input.
 *
 * As an example, consider the command: 
 *
 *    $tsv-summary --key-field 1 --mean 3 --mean 5
 *
 * This command will create two instances of a MeanOperator, one each for fields 3 and 5.
 * They produce the output field headers (e.g. "field3_mean", "field5_mean"). They also
 * create MeanCalculator objects for each unique value in field 1. For 'mean', a
 * calculator needs to track occurrence count and sum. Calculators produce the final
 * value when all processing is finished.
 *
 * Summary field headers
 *
 * There are several options for specifing summary field headers. The defaults combine the
 * operator name and the header of the field summarized. The defaults can be overridden on
 * on the command line. These scenarios are supported via the operator constructor and the
 * processHeaderLine() method.
 */

interface Operator
{
    @property string header();
    void processHeaderLine(const char[][] fields);
    Calculator makeCalculator();
}

interface Calculator
{
    void processNextLine(const char[][] fields);
    string calculate();
}

/* SingleFieldOperator is a base class for single field operators, the most common
 * Operator. Derived classes implement makeCalculator and the Calculator class it returns.
 */
class SingleFieldOperator : Operator
{
    private string _name;
    private string _header;
    private size_t _fieldIndex;
    private bool _hasCustomHeader;

    this(string operatorName, size_t fieldIndex, string summaryHeader, bool hasCustomHeader = true)
    {
        _name = operatorName;
        _fieldIndex = fieldIndex;
        _header = summaryHeader;
        _hasCustomHeader = hasCustomHeader;
    }

    this(string operatorName, size_t fieldIndex)
    {
        string defaultHeader = "field" ~ (fieldIndex + 1).to!string ~ "_" ~ operatorName;
        this(operatorName, fieldIndex, defaultHeader, false);
    }

    final string name() const @property
    {
        return _name;
    }

    final size_t fieldIndex() const @property
    {
        return _fieldIndex;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields)
    {
        if (!_hasCustomHeader) {
            debug writefln("[processHeaderLine %s %d] fields: %s", _name, _fieldIndex, fields.to!string);
            _header = fields[_fieldIndex].to!string ~ "_" ~ _name;
        }
    }

    abstract Calculator makeCalculator();
}

/* SingleFieldCalculator is a base class for the common case of calculators using a single
 * field. Derived classes implement processNextField() rather than processNextLine().
 */
class SingleFieldCalculator : Calculator
{
    private size_t _fieldIndex;
    
    this(size_t fieldIndex)
    {
        _fieldIndex = fieldIndex;
    }

    void processNextLine(const char[][] fields)
    {
        debug writefln("[processNextLine %s %d] fields: %s", this.to!string, _fieldIndex, fields.to!string);
        processNextField(fields[_fieldIndex]);
    }
    
    abstract void processNextField(const char[] field);
}

/* Specific operators.
 *
 * Notes: 
 * - The 'Calculator' inner classes are 'static'. This means inner class instances do not
 *   keep a reference to the context of the outer class. In exchange, Calculator instances
 *   need to hold all needed state, typically the field index they are summarizing.
 */

/* CountOperator counts the number of occurrences of each unique key. It differs from most
 * operators in that it doesn't summarize a specific field. Instead it is summarizing a 
 * property of the unique key itself. For this reason it doesn't use SingleFieldOperator.
 */
class CountOperator : Operator
{
    private string _name = "count";
    private string _header = "count";

    this() { }

    this(string summaryHeader)
    {
        _header = summaryHeader;
    }

    final string name() const @property
    {
        return _name;
    }

    final string header() const @property
    {
        return _header;
    }

    void processHeaderLine(const char[][] fields) { }
    
    final Calculator makeCalculator()
    {
        return new CountCalculator();
    }

    static class CountCalculator : Calculator
    {
        private size_t _count = 0;

        final void processNextLine(const char[][] fields)
        {
            debug writefln("[processNextLine %s] fields: %s", this.to!string, fields.to!string);
            _count++;
        }
        
        final string calculate()
        {
            return _count.to!string;
        }
    }
}


class RetainOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("retain", fieldIndex);
    }

    override void processHeaderLine(const char[][] fields)
    {
        debug writefln("[processHeaderLine %s %d] fields: %s", _name, _fieldIndex, fields.to!string);
        _header = fields[fieldIndex].to!string;
    }

    final override Calculator makeCalculator()
    {
        return new RetainCalculator(fieldIndex);
    }

    /* RetainOperator is similar to FirstOperator, except that it preserves the original
     * field name. The intent is for fields that are expected to have same value for each
     * unique key, therefore there is no meaningful summarization to do. However, it may
     * be useful to keep in the output.
     */
    static class RetainCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }
        
        final string calculate()
        {
            return _value;
        }
    }
}


class FirstOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("first", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("first", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new FirstCalculator(fieldIndex);
    }
    
    static class FirstCalculator : SingleFieldCalculator
    {
        private bool _done = false;
        private string _value = "";

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            if (!_done)
            {
                _value = nextField.to!string;
                _done = true;
            }
        }

        final string calculate()
        {
            return _value;
        }
    }
}

class LastOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("last", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("last", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new LastCalculator(fieldIndex);
    }

    static class LastCalculator : SingleFieldCalculator
    {
        private string _value = "";
        
        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }
        
        final override void processNextField(const char[] nextField)
        {
            _value = nextField.to!string;
        }
        
        final string calculate()
        {
            return _value;
        }
    }
}

class MinOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("min", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("min", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MinCalculator(fieldIndex);
    }

    static class MinCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue < _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate()
        {
            return _value.to!string;
        }
    }
}
        
class MaxOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("max", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("max", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MaxCalculator(fieldIndex);
    }

    static class MaxCalculator : SingleFieldCalculator
    {
        private bool _isFirst = true;
        private double _value = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            double fieldValue = nextField.to!double;
            if (_isFirst)
            {
                _value = fieldValue;
                _isFirst = false;
            }
            else if (fieldValue > _value)
            {
                _value = fieldValue;
            }
        }
        
        final string calculate()
        {
            return _value.to!string;
        }
    }
}
        
class SumOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("sum", fieldIndex);
    }

    this(size_t fieldIndex, string summaryHeader)
    {
        super("sum", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new SumCalculator(fieldIndex);
    }

    static class SumCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
        }

        final string calculate()
        {
            return _total.to!string;
        }
    }
}

class MeanOperator : SingleFieldOperator
{
    this(size_t fieldIndex)
    {
        super("mean", fieldIndex);
    }
    
    this(size_t fieldIndex, string summaryHeader)
    {
        super("mean", fieldIndex, summaryHeader);
    }

    final override Calculator makeCalculator()
    {
        return new MeanCalculator(fieldIndex);
    }

    static class MeanCalculator : SingleFieldCalculator
    {
        private double _total = 0.0;
        private size_t _count = 0;

        this(size_t fieldIndex)
        {
            super(fieldIndex);
        }

        final override void processNextField(const char[] nextField)
        {
            _total += nextField.to!double;
            _count++;
        }
        
        final string calculate()
        {
            return (_total / cast(double) _count).to!string;
        }
    }
}

/* A Summarizer maintains the state of the summarization and performs basic processing.
 * Handling of files and input lines is left to the caller.
 * API:
 * - addOperator - Called after initializing the object for each operator to be processed.
 * - processHeaderLine - Called to process the header line of each file. Returns true if
 *   it was the first header line processed (used when reading multiple files).
 * - processNextLine - Called to process non-header lines.
 * - writeSummaryHeader - Called to write the header line.
 * - writeSummaryBody - Called to write the result lines.
 */
interface Summarizer(OutputRange)
{
    void addOperator(Operator op);
    bool processHeaderLine(const char[][] lineFields);
    void processNextLine(const char[][] lineFields);
    void writeSummaryHeader(ref OutputRange outputStream);
    void writeSummaryBody(ref OutputRange outputStream);
}

class SummarizerBase(OutputRange) : Summarizer!OutputRange
{
    private char _fieldDelimiter;
    private bool _hasProcessedFirstHeaderLine = false;
    protected DList!Operator _operators;
    protected size_t _numOperators = 0;

    this(const char fieldDelimiter)
    {
        _fieldDelimiter = fieldDelimiter;
    }

    char fieldDelimiter() const @property
    {
        return _fieldDelimiter;
    }

    void addOperator(Operator op)
    {
        _operators.insertBack(op);
        _numOperators++;
    }

    bool processHeaderLine(const char[][] lineFields)
    {
        if (!_hasProcessedFirstHeaderLine)
        {
            _operators.each!(x => x.processHeaderLine(lineFields));
            _hasProcessedFirstHeaderLine = true;
            return true;
        }
        else
        {
            return false;
        }
    }

    abstract void processNextLine(const char[][] lineFields);
    abstract void writeSummaryHeader(ref OutputRange outputStream);
    abstract void writeSummaryBody(ref OutputRange outputStream);
}

/* This Summarizer a single summary for all the values in column.
 */
class NoKeySummarizer(OutputRange) : SummarizerBase!OutputRange
{
    private Calculator[] _calculators;

    this(const char fieldDelimiter)
    {
        super(fieldDelimiter);
    }

    /* Since there's only one Calculator per field, add them as Operators are added. */
    override void addOperator(Operator op)
    {
        super.addOperator(op);
        _calculators ~= op.makeCalculator;
    }

    override void processNextLine(const char[][] lineFields)
    {
        _calculators.each!(x => x.processNextLine(lineFields));
    }

    override void writeSummaryHeader(ref OutputRange outputStream)
    {
        put(outputStream, _operators[].map!(op => op.header).join(fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream)
    {
        put(outputStream, _calculators[].map!(x => x.calculate).join(fieldDelimiter));
        put(outputStream, '\n');
    }
}

class KeySummarizerBase(OutputRange) : SummarizerBase!OutputRange
{
    private DList!string _uniqueKeys;
    private Calculator[][string] _uniqueKeyCalculators;

    this(const char fieldDelimiter)
    {
        super(fieldDelimiter);
    }
    
    protected Calculator[] addUniqueKey(string key)
    {
        assert(key !in _uniqueKeyCalculators);

        _uniqueKeys.insertBack(key);
        
        auto calculators = new Calculator[_numOperators];
        size_t i = 0;
        foreach (op; _operators)
        {
            calculators[i] = op.makeCalculator;
            i++;
        }
        return _uniqueKeyCalculators[key] = calculators;
    }
    
    override void writeSummaryHeader(ref OutputRange outputStream)
    {
        put(outputStream, keyFieldHeader());
        put(outputStream, fieldDelimiter);
        put(outputStream, _operators[].map!(op => op.header).join(fieldDelimiter));
        put(outputStream, '\n');
    }
    
    override void writeSummaryBody(ref OutputRange outputStream)
    {
        foreach(key; _uniqueKeys)
        {
            put(outputStream, key);
            put(outputStream, fieldDelimiter);
            put(outputStream, _uniqueKeyCalculators[key][].map!(x => x.calculate).join(fieldDelimiter));
            put(outputStream, '\n');
        }
    }
    
    abstract string keyFieldHeader() const @property;
}

/* This Summarizer is for the case where the unique key is based on exactly one field.
 */
class OneKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t _keyFieldIndex = 0;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(size_t keyFieldIndex, char fieldDelimiter)
    {
        super(fieldDelimiter);
        _keyFieldIndex = keyFieldIndex;
        _keyFieldHeader = "field" ~ (keyFieldIndex + 1).to!string;
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex <= lineFields.length);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = lineFields[_keyFieldIndex].to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndex < lineFields.length);

        Calculator[]* calculatorsPtr = (lineFields[_keyFieldIndex] in _uniqueKeyCalculators);
        Calculator[] calculators = (calculatorsPtr is null) ?
            addUniqueKey(lineFields[_keyFieldIndex].to!string) : *calculatorsPtr;
        
        calculators.each!(x => x.processNextLine(lineFields));
    }
}

/* This Summarizer is for the case where the unique key is based on multiple fields.
 */
class MultiKeySummarizer(OutputRange) : KeySummarizerBase!OutputRange
{
    private size_t[] _keyFieldIndices;
    private string _keyFieldHeader;
    private DList!string _uniqueKeys;

    this(const size_t[] keyFieldIndices, char fieldDelimiter)
    {
        super(fieldDelimiter);
        _keyFieldIndices = keyFieldIndices.dup;
        _keyFieldHeader = _keyFieldIndices.map!(x => "field" ~ (x + 1).to!string).join(fieldDelimiter);
    }

    override string keyFieldHeader() const @property
    {
        return _keyFieldHeader;
    }

    override bool processHeaderLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        bool isFirstHeaderLine = super.processHeaderLine(lineFields);
        if (isFirstHeaderLine)
        {
            _keyFieldHeader = _keyFieldIndices.map!(i => lineFields[i]).join(fieldDelimiter).to!string;
        }
        return isFirstHeaderLine;
    }

    override void processNextLine(const char[][] lineFields)
    {
        assert(_keyFieldIndices.all!(x => x < lineFields.length));
        assert(_keyFieldIndices.length >= 2);
        
        string key = _keyFieldIndices.map!(i => lineFields[i]).join(fieldDelimiter).to!string;
        Calculator[]* calculatorsPtr = (key in _uniqueKeyCalculators);
        Calculator[] calculators = (calculatorsPtr is null) ? addUniqueKey(key) : *calculatorsPtr;

        calculators.each!(x => x.processNextLine(lineFields));
    }
}


    
